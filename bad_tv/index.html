<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>Bad TV</title>

<script type="bitsyGameData" id="exportedGameData">
Bad TV

# BITSY VERSION 5.3

! ROOM_FORMAT 1

PAL 0
NAME starting
3,103,204
181,67,255
255,255,255

PAL 1
NAME horror
0,0,0
255,255,255
0,0,0

PAL 2
NAME sleep
68,76,119
255,255,255
68,76,119

PAL 3
NAME field
148,255,163
17,212,70
38,4,255

PAL 4
NAME bear
248,248,248
39,53,54
248,248,248

PAL 5
NAME bearfield
148,255,163
248,248,248
17,212,70

PAL 6
NAME grave
117,91,60
148,255,163
117,91,60

ROOM 0
g2,g1,f7,0,fq,f9,f9,f9,f9,f9,f9,fp,j,j,j,j
j,j,f7,0,fr,0,0,d,e,0,0,fk,j,j,j,j
j,j,f7,0,0,0,0,f,g,0,0,fk,j,j,j,j
j,j,fo,fj,fb,0,0,0,0,0,0,fk,j,j,j,j
fy,fz,g0,j,f7,0,0,0,0,0,0,fk,j,j,j,j
f9,f9,f9,f9,fe,0,0,0,0,0,0,fc,f9,f9,fp,j
0,0,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
fj,fb,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
j,f7,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
j,f7,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
j,f7,0,0,0,0,0,0,0,0,0,fl,fj,fj,fm,j
j,f7,0,0,0,0,0,0,0,0,0,fk,j,j,j,j
j,f7,0,0,0,0,0,0,0,0,0,fk,j,j,j,j
j,f7,0,0,0,0,0,0,0,0,0,fk,j,j,j,j
j,fo,fj,fb,0,fl,fj,fj,fj,fb,0,fk,j,j,j,j
j,ft,fs,f7,0,fk,j,j,j,f7,0,fk,fu,fv,fw,fx
NAME starting room
EXT 7,2 6 6,2
EXT 8,2 6 6,2
END 0 3,0
PAL 0

ROOM 2
g2,g1,f7,0,fq,f9,f9,f9,f9,f9,f9,fp,j,j,j,j
j,j,f7,0,fr,0,0,d,e,0,0,fk,j,j,j,j
j,j,f7,0,0,0,0,f,g,0,0,fk,j,j,j,j
j,j,fo,fj,fb,0,0,0,0,0,0,fk,j,j,j,j
fy,fz,g0,j,f7,0,0,0,0,0,0,fk,j,j,j,j
f9,f9,f9,f9,fe,0,0,0,0,0,0,fc,f9,f9,fp,j
0,0,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
fj,fb,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
j,f7,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
j,f7,0,0,0,0,0,0,0,0,0,0,0,0,fk,j
j,f7,0,0,0,0,0,0,0,0,0,fl,fj,fj,fm,j
j,f7,0,0,0,0,0,0,0,0,0,fk,j,j,j,j
j,f7,0,0,0,0,0,0,0,0,0,fk,j,j,j,j
j,f7,0,0,0,0,0,0,0,0,0,fk,j,j,j,j
j,fo,fj,fb,0,fl,fj,fj,fj,fb,0,fk,j,j,j,j
j,ft,fs,f7,0,fk,j,j,j,f7,0,fk,fu,fv,fw,fx
NAME decision room
EXT 3,0 4 3,15
EXT 7,2 6 6,2
EXT 8,2 6 6,2
PAL 0

ROOM 4
j,j,j,j,j,j,j,j,j,j,j,j,g2,g1,fq,f9
j,j,fq,f9,f9,f9,f9,f9,f9,f9,f9,f9,f9,f9,fe,0
j,j,f7,0,0,0,0,0,0,0,0,0,0,0,0,0
j,j,f7,0,fl,fj,fj,fj,fj,fj,fj,fj,fj,fj,fb,0
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,f7,0
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,fo,fj
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,j,j,j,j,j,j,j,j,j,j,j
j,j,f7,0,fk,g4,g5,g6,g7,g8,j,j,j,j,j,j
NAME hallway
EXT 15,2 7 2,2
EXT 3,15 2 3,0
PAL 0

ROOM 6
0,0,0,1,2,3,4,5,6,g3,7,8,9,a,b,c
m,n,0,o,0,p,0,0,q,r,s,t,0,u,v,w
x,y,0,0,0,0,0,0,z,g3,10,0,11,12,13,14
g3,15,0,16,17,0,0,18,19,g3,1a,1b,1c,1d,1e,1f
1g,0,1h,g3,1i,1j,1k,1l,1m,1n,1o,1p,19,g3,g3,1q
1r,0,1s,g3,g3,1t,1u,1v,g3,g3,g3,g3,1w,g3,g3,1x
1y,1z,20,g3,21,22,23,24,g3,g3,g3,g3,25,6,g3,26
g3,27,28,g3,29,0,2a,g3,g3,g3,g3,2b,g3,2c,2d,2e
2f,g3,2g,g3,2h,2i,2j,0,0,0,2k,2l,2m,2n,2o,2p
2q,g3,2r,2s,g3,2t,2u,2v,2w,2x,2y,0,2z,22,30,g3
31,g3,g3,32,33,34,35,g3,36,g3,37,38,39,3a,3b,g3
3c,g3,g3,3d,3e,3f,3g,3h,g3,3i,3j,3k,3l,3m,g3,g3
0,3n,g3,g3,3o,3p,3q,3r,3s,3t,3u,3v,0,3w,g3,g3
0,3x,g3,g3,3y,0,3z,40,g3,g3,g3,41,42,g3,g3,g3
0,g3,g3,g3,44,45,46,g3,g3,g3,g3,47,48,g3,g3,g3
49,g3,g3,g3,4a,4b,4c,g3,g3,g3,4d,4e,4f,4g,g3,g3
NAME popup
EXT 6,1 2 7,3
EXT 5,2 2 7,3
EXT 7,2 2 7,3
EXT 6,3 2 7,3
PAL 1

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,4l,4m,0,4h,4i,0
0,0,0,0,0,0,0,0,4h,4i,4n,4o,0,4j,4k,0
0,0,0,0,0,0,4l,4m,4j,4k,0,0,0,0,0,0
0,0,0,0,0,0,4n,4o,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,4h,4i,0,0,0,0,0,0,0,0,0,0
0,0,0,0,4j,4k,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bedroom
EXT 2,1 8 7,8
EXT 1,2 8 7,8
EXT 3,2 8 7,8
EXT 2,3 8 7,8
PAL 2

ROOM 8
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,4p,0,0,0,0,0,0,0,4p,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4p
0,0,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,4p,0,0,0,0,0,0,0,4p,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0
0,0,0,0,0,4p,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0,0
0,4p,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
0,0,0,0,4p,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME field
EXT 14,5 a 14,5
PAL 3

ROOM 10
g9,g9,g9,g9,g9,g9,g9,g9,g9,4q,88,4s,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,4t,89,0,2f,g9,g9,g9
g9,g9,g9,g9,g9,g9,4v,8a,8b,4y,8c,8d,51,g9,g9,g9
g9,g9,g9,g9,g9,8e,8f,8g,8h,8i,0,8j,58,g9,g9,g9
g9,g9,g9,8k,8l,8m,8n,8o,8p,0,0,5f,5g,5h,g9,g9
g9,g9,g9,8q,8r,8s,8t,8u,8v,0,0,5p,0,5q,g9,g9
g9,g9,8w,8x,8y,8z,90,91,92,5x,5y,5z,0,60,g9,g9
g9,g9,93,94,95,96,97,98,99,9a,69,9b,0,6b,g9,g9
g9,g9,9c,9d,9e,9f,9g,9h,9i,9j,6k,6l,0,6m,g9,g9
g9,g9,9k,9l,9m,9n,9o,9p,9q,9r,9s,0,0,9t,g9,g9
g9,g9,9u,9v,9w,9x,9y,9z,a0,a1,a2,0,0,a3,g9,g9
g9,g9,a4,a5,5o,a6,a7,a8,a9,aa,ab,0,0,7h,g9,g9
g9,g9,7i,ac,0,7k,ad,ae,7n,7o,af,0,ag,3b,g9,g9
g9,g9,g9,7r,ah,0,0,0,7u,0,0,ai,g9,g9,g9,g9
g9,g9,g9,g9,7x,ak,al,am,an,82,ao,ap,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,84,aq,ar,as,g9,g9,g9,g9,g9,g9
NAME bear
EXT 12,8 11 3,10
EXT 11,9 11 3,10
EXT 13,9 11 3,10
EXT 12,10 11 3,10
PAL 4

ROOM 11
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,cw,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,cx,cy,cz,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,d0,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,d1,d2,d3,d4,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,d5,d6,d7,d8,d9,da,db,dc,g9,g9
g9,g9,g9,cd,dd,de,df,dg,dh,di,dj,dk,dl,dm,g9,g9
g9,g9,dn,do,dp,dq,dr,ds,dt,du,dv,dw,dx,dy,g9,g9
g9,dz,e0,0,e1,e2,e3,e4,e5,e6,e7,e8,e9,g9,g9,g9
ea,eb,7u,ec,ed,ee,b9,ef,eg,eh,g9,g9,g9,g9,g9,g9
ei,ej,ek,el,em,en,eo,ep,eq,er,g9,g9,g9,g9,g9,g9
g9,es,et,eu,ev,ew,ex,ey,g9,g9,g9,g9,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9
g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9,g9
NAME grave
END 1 3,9
END 1 2,10
END 1 4,10
END 1 3,11
PAL 6

ROOM a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,4p,0,0,0,0,0,0,0,4p,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4p
0,0,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
ez,f0,f1,f2,0,0,0,0,0,0,0,0,0,0,0,0
f3,f4,f5,f6,0,0,0,0,0,0,0,4p,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0
0,0,0,0,0,4p,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0,0
0,4p,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bearfield1
EXT 14,4 b 14,5
EXT 13,5 b 14,5
EXT 15,5 b 14,5
EXT 14,6 b 14,5
PAL 5

ROOM b
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,4p,0,0,0,0,0,0,0,4p,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4p
0,0,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
0,0,0,0,0,ez,f0,f1,f2,0,0,0,0,0,0,0
0,0,0,4p,0,f3,f4,f5,f6,0,0,4p,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0
0,0,0,0,0,4p,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0,0
0,4p,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
0,0,0,0,4p,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bearfield2
EXT 14,4 c 14,5
EXT 13,5 c 14,5
EXT 15,5 c 14,5
EXT 14,6 c 14,5
PAL 5

ROOM c
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,4p,0,0,0,0,0,0,0
0,0,4p,0,0,0,0,0,0,0,4p,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4p
0,0,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,ez,f0,f1
0,0,0,4p,0,0,0,0,0,0,0,4p,0,f3,f4,f5
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0
0,0,0,0,0,4p,0,0,4p,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0,0
0,4p,0,0,0,0,4p,0,0,0,0,0,0,0,0,0
0,0,0,0,4p,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,4p,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bearfield3
EXT 14,4 10 12,9
EXT 13,5 10 12,9
EXT 15,5 10 12,9
EXT 14,6 10 12,9
PAL 5

TIL 1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME popup 1

TIL 2
00000000
00000000
00000000
00000000
00000000
00000000
01111111
10000000
NAME popup 2

TIL 3
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00111000
NAME popup 3

TIL 4
00111111
00001111
00000011
00000000
00000000
00000000
00000000
00000000
NAME popup 4

TIL 5
11111111
11111111
11111111
00111111
00000111
00000000
00000000
00000000
NAME popup 5

TIL 6
11111111
11111111
11111111
11111111
11111111
11111111
01111111
01111111
NAME popup 6

TIL 7
11111100
11111000
11110000
11000000
11000000
10000000
00000001
00000011
NAME popup 7

TIL 8
00000000
00000000
00000000
00000000
00000111
00111111
11100000
10000000
NAME popup 8

TIL 9
00000000
00000000
00000000
00000000
11111111
11111111
00000000
00000000
NAME popup 9

TIL 10
10000000
10000000
11000000
11100000
11100000
00000000
10000000
10000000
NAME popup 27

TIL 11
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00011111
NAME popup 28

TIL 12
00000000
00000000
00000000
00000001
00000111
01111100
11100000
10000000
NAME popup 29

TIL 13
01110000
01111000
11111000
11100000
11000000
00000000
00000000
00000000
NAME popup 30

TIL 14
11000111
11100111
11000011
01000011
01100011
01100001
00000000
00000000
NAME popup 31

TIL 15
11000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME popup 32

TIL 16
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001111
NAME popup 33

TIL 17
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME popup 34

TIL 18
00000000
00000000
00000001
00000011
00000011
00000011
00000011
00000001
NAME popup 35

TIL 19
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 36

TIL 20
00011111
00011111
00111111
00111111
00111111
01111111
11111111
11111111
NAME popup 63

TIL 21
11111111
11111111
11111111
11111111
11111110
11111100
11111000
11111000
NAME popup 64

TIL 22
11000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME popup 65

TIL 23
00000000
00000000
00000000
00000000
00000000
00000000
00000111
00000111
NAME popup 66

TIL 24
11111111
01111111
00011111
00011111
00111111
01111111
11111111
11111111
NAME popup 67

TIL 25
11111011
11111001
11111101
11111101
11111110
11111110
11111110
11111111
NAME popup 68

TIL 26
11111100
11111100
11111000
11111000
11110000
11110000
11100000
11100000
NAME popup 69

TIL 27
10000000
11000000
11100000
11100000
11110000
11111000
11111100
11111100
NAME popup 70

TIL 28
11111111
01111111
01111111
00111111
00111111
00011111
00011111
00011111
NAME popup 71

TIL 29
11111000
11111000
11111000
11110000
11110000
11110000
11110000
11110000
NAME popup 72

TIL 30
00000111
00000111
00001111
00001111
00011111
00011111
00111111
01111111
NAME popup 99

TIL 31
00001111
00011111
00011111
00011111
00011111
00011111
00011111
00001111
NAME popup 100

TIL 32
00000111
00000111
10000011
11000001
11110000
11110000
11111000
11111000
NAME popup 101

TIL 33
11111111
11111111
11111111
11111111
01111111
01111111
00111011
00010011
NAME popup 102

TIL 34
10000111
00000011
00000001
10000000
11000000
11000000
11000000
11100000
NAME popup 103

TIL 35
11111111
11111111
11111111
01100111
00000111
00000011
00000001
00000000
NAME popup 104

TIL 36
11000111
11000111
11101111
11101111
11001111
11111111
11011111
11111111
NAME popup 105

TIL 37
11110000
11110000
11110000
11110000
11110000
11110000
11110000
11000000
NAME popup 106

TIL 38
00000000
00000000
00000001
00000001
00000011
00000011
00000011
00000111
NAME popup 107

TIL 39
11110000
11110000
11100000
11100000
11000000
11000000
10000000
10000000
NAME popup 108

TIL 40
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011111
NAME popup 135

TIL 41
11111100
11111100
11111000
11111000
11111000
11110000
11110000
11111000
NAME popup 136

TIL 42
00000001
00000000
00000001
00000001
00000011
00000011
00000011
00000111
NAME popup 137

TIL 43
01111111
01111111
01111111
01111111
01111111
11111111
11111111
11111111
NAME popup 138

TIL 44
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME popup 139

TIL 45
00000000
00000000
00000000
00000011
00000011
00000011
00000111
00000111
NAME popup 140

TIL 46
00011111
00011111
00111111
11111111
11111111
11111111
10111111
11111111
NAME popup 141

TIL 47
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME popup 142

TIL 48
00000111
00000111
00000111
00000011
00000011
00000011
00000011
00000011
NAME popup 143

TIL 49
00000001
00000001
00000011
00000111
00000111
00000111
00001111
00000111
NAME popup 144

TIL 50
00000000
00000000
00000000
00000000
10000000
01000000
00000000
00000000
NAME bear 11

TIL 51
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME bear 12

TIL 52
11111111
11111111
11111111
11111111
11111111
11110111
11111101
11111100
NAME bear 13

TIL 53
11011110
11111110
11111110
11011111
11111111
11011111
00111110
11111101
NAME bear 14

TIL 54
00000000
00000000
00000000
11011000
01111100
11010010
01101100
10011000
NAME bear 15

TIL 55
01101111
00111111
01111111
10110111
00111111
11011111
01111101
01111011
NAME bear 16

TIL 56
11101110
11101100
11001100
11000100
10000100
10000000
00000000
00000000
NAME bear 17

TIL 57
00010000
00011000
00011000
00001000
00001000
00000000
01000000
00000000
NAME bear 18

TIL 58
00111111
00111111
00011111
00000111
00000111
00000011
00000011
00000001
NAME bear 19

TIL 59
11111111
11111111
11111111
11111111
11111001
11110000
11000000
11110000
NAME bear 20

TIL 60
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011
NAME bear 47

TIL 61
11111111
11011111
11110111
11111111
11010101
11111111
11111111
11111111
NAME bear 48

TIL 62
11111110
11111100
11111101
11111111
11111101
11011100
11101100
11111100
NAME bear 49

TIL 63
01001011
00100111
00110010
00000111
10011011
10011011
01010111
00101111
NAME bear 50

TIL 64
11110100
00111000
11001011
10100100
10110000
10100000
11101000
10111000
NAME bear 51

TIL 65
11000100
00001110
00000001
01000000
10000101
10000000
00000000
00100000
NAME bear 52

TIL 66
01000000
01010100
00000000
10000010
00000001
10001010
01000100
00001000
NAME bear 53

TIL 67
01011110
01011101
10011000
00111111
01010101
00110001
01000010
10010110
NAME bear 54

TIL 68
00100000
00000011
10000000
00000001
00000000
00000000
00000000
10010000
NAME bear 55

TIL 69
00100000
00110010
00010000
10111110
01010000
00010000
00100000
00010000
NAME bear 56

TIL 70
00101000
00101000
00000000
00000000
01000000
01000000
00001000
00000000
NAME bear 83

TIL 71
10000000
10000001
00000000
00110000
00001011
00000001
00000001
00000001
NAME bear 84

TIL 72
00001000
10000000
10000000
10001000
00000000
00000001
10100011
10011101
NAME bear 85

TIL 73
00000011
00000000
00000000
00000000
00100101
10000100
10000000
11001010
NAME bear 86

TIL 74
00000000
00000000
00000000
00000000
00000000
00011000
01000010
00000111
NAME bear 87

TIL 75
00000000
00000000
00000000
00011000
00000010
00000000
00000010
00010100
NAME bear 88

TIL 76
00000000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear 89

TIL 77
00000001
00000001
00000011
00000011
00000011
00000101
00000111
00000011
NAME bear 90

TIL 78
11101001
10000000
11000000
11110000
11001000
11101100
11111100
11111010
NAME bear 91

TIL 79
00000000
01001000
11111000
00001000
00001100
10001010
00000000
00000000
NAME bear 92

TIL 80
00000000
00000000
00000000
00000000
00000000
10000000
00100010
11010010
NAME bear 119

TIL 81
01000000
10000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME bear 120

TIL 82
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000010
NAME bear 121

TIL 83
00001000
00000011
00000001
00001011
00011111
01110111
10111111
11111111
NAME bear 122

TIL 84
11111011
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear 123

TIL 85
11110100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear 124

TIL 86
00000000
01000000
11111000
11111001
11111111
11111111
11111111
11111111
NAME bear 125

TIL 87
00100011
00100111
01111111
01111111
10111111
11111111
11111111
11111111
NAME bear 126

TIL 88
11111111
11111111
11111111
11000001
10000000
00000000
00000000
00000001
NAME bear 127

TIL 89
00000100
01101000
11000000
11000000
10110000
11000000
11000000
01000000
NAME bear 128

TIL 90
00000000
00000111
11011000
00011111
10010001
01110000
11110000
11100000
NAME bear 155

TIL 91
00001100
00000001
00000011
01001011
11000111
00100010
00000111
00000001
NAME bear 156

TIL 92
00011001
10111001
10000001
01000001
00000100
00000000
10100011
00100000
NAME bear 157

TIL 93
11110111
11011111
11100111
11111111
11010101
11110111
11011011
10111110
NAME bear 158

TIL 94
11111110
11011100
11111101
11111101
11111101
11011100
11101000
11111000
NAME bear 159

TIL 95
01001011
00000110
00010010
00000111
10011011
00010011
00000111
00101011
NAME bear 160

TIL 96
11110100
00111000
01001001
00100100
00110000
10100000
11101000
10110000
NAME bear 161

TIL 97
11000100
00001110
00000000
00000000
00000100
00000000
00000000
00100000
NAME bear 162

TIL 98
00000000
00000100
00000000
00000010
00000000
10001000
01000000
00001000
NAME bear 163

TIL 99
01011100
01011100
10011000
00101110
01010101
00110001
00000010
00000110
NAME bear 164

TIL d
00000000
00000100
00000010
00011111
00010000
00010000
00010000
00010000
>
00000000
00000100
00000010
00011111
00010001
00010010
00010010
00010001
NAME tv topright
WAL true

TIL e
00000000
00100000
01000000
11111000
00001000
00001000
00001000
00001000
>
00000000
00100000
01000000
11111000
10001000
01001000
01001000
10001000
NAME tv topleft
WAL true

TIL f
00010000
00010000
00011111
00000100
00000100
00000000
00000000
00000000
>
00010110
00010100
00011111
00000100
00000100
00000000
00000000
00000000
NAME tv bottomleft

TIL g
00001000
00001000
11111000
00100000
00100000
00000000
00000000
00000000
>
01101000
00101000
11111000
00100000
00100000
00000000
00000000
00000000
NAME tv bottomright

TIL h
11111111
11110000
00000000
00111100
00000000
00001111
00000000
11111111
NAME back wall
WAL true

TIL i
10000001
10111001
10000001
10011101
10000001
10000001
10001111
10000001
NAME side wall
WAL true

TIL j
00000000
01000100
00000010
00001000
00010000
00000000
01000010
00000000
NAME outside

TIL a
00000000
00000000
00000000
00000000
10000000
11110000
01111000
00001110
NAME popup 10

TIL b
00001000
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME popup 11

TIL c
01110000
00110000
00011000
10011000
11001111
11101111
01110011
01100000
NAME popup 12

TIL m
00000000
00000111
00000111
00001111
00000111
00000111
00000111
00001111
NAME popup 13

TIL n
00000000
11000000
11100000
11100000
11110000
11110000
11110000
11111000
NAME popup 14

TIL o
00000111
00000000
00110000
00000000
00000000
10000000
00000000
00000000
NAME popup 15

TIL p
00111000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME popup 16

TIL q
00111111
00011111
00001111
00001111
00001111
00001111
00001111
00001111
NAME popup 17

TIL r
11111111
11111110
11111100
11111100
11111100
11111001
11111001
11111111
NAME popup 18

TIL s
00000111
00001110
01111100
01111100
11110000
11110000
11100000
11000000
NAME popup 19

TIL t
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME popup 20

TIL u
00001110
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME popup 21

TIL v
00000000
00000000
10000000
11000000
11000000
01100000
01100000
01110000
NAME popup 22

TIL w
00100000
00000001
01000111
00001111
00001111
00001111
00001111
00000111
NAME popup 23

TIL x
00011111
00111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME popup 24

TIL y
11111000
11110000
11110000
11110000
11100000
11100000
11100000
11000000
NAME popup 25

TIL z
00011111
00111111
00011111
00001111
00011111
00011111
00111111
01111111
NAME popup 26

TIL 1a
11000000
11110000
11111000
11111110
11111111
11111111
11111111
11111111
NAME popup 37

TIL 1b
00000000
00000000
00000000
00000001
00000111
11000111
11100011
11110001
NAME popup 38

TIL 1c
00011111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 39

TIL 1d
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 40

TIL 1e
00000000
10000111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 41

TIL 1f
00000000
11000000
11110000
11111100
11111100
11111100
11111100
11111100
NAME popup 42

TIL 1g
11111111
11111110
11111110
11111100
11111100
11111100
11111000
11111000
NAME popup 43

TIL 1h
00000011
00000111
00111111
00011111
00001111
00001111
00000111
00001111
NAME popup 44

TIL 1i
11111000
11111100
11111000
11110000
11110000
11110000
11111111
11111111
NAME popup 45

TIL 1j
00000000
00000000
00000000
00000000
00000000
01000000
11001000
11011000
NAME popup 46

TIL 1k
00000000
00000000
00000001
00000111
00001111
00001111
00011111
00011111
NAME popup 47

TIL 1l
00000000
00000000
11000000
00000000
00000000
00000000
10000000
11001111
NAME popup 48

TIL 1m
11111111
01111111
01111111
00011111
00011111
00001111
00001111
10011111
NAME popup 49

TIL 1n
11111111
11111111
11111100
11111100
11111110
11111111
11111111
11111111
NAME popup 50

TIL 1o
11111111
11111111
11111111
00011111
00001111
00001111
11111111
11111111
NAME popup 51

TIL 1p
11111000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 52

TIL 1q
11111100
11111100
11111110
11111110
11111110
11111110
11111111
11111111
NAME popup 53

TIL 1r
11111000
01111000
00111100
10011100
11000000
11100000
11100000
11110000
NAME popup 54

TIL 1s
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME popup 55

TIL 1t
11111110
11111111
11111111
11111111
11111000
11110000
11100000
11000000
NAME popup 56

TIL 1u
00000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME popup 57

TIL 1v
11111111
11111111
00111111
01111111
01111111
11111111
11111111
11111111
NAME popup 58

TIL 1w
01111111
10111111
10011111
11001111
11001111
11100111
11110011
11110011
NAME popup 59

TIL 1x
11111110
11111111
11111111
11111110
11111110
11111110
11111100
11111100
NAME popup 60

TIL 1y
11110000
11111000
11111000
11111100
11111110
11111110
11111111
11111111
NAME popup 61

TIL 1z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME popup 62

TIL 2a
00001111
00011111
00000111
00000111
00000111
00011111
01111111
01111111
NAME popup 73

TIL 2b
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME popup 74

TIL 2c
00111111
00111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME popup 75

TIL 2d
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111100
NAME popup 76

TIL 2e
11000000
11000000
10000000
00000001
00000011
00000111
00001111
00011111
NAME popup 77

TIL 2f
11111111
11111111
11111111
11111111
01111111
01111111
01111111
01111111
NAME popup 78

TIL 2g
00001111
00000111
00000111
10000111
10000011
11000011
11000001
11100001
NAME popup 79

TIL 2h
11110000
11110000
11110001
11110001
11111011
11111111
11111111
11111111
NAME popup 80

TIL 2i
00000000
00000000
10000000
11000000
11100001
00000100
00000000
00000000
NAME popup 81

TIL 2j
00111111
00111110
00111110
11111110
11101000
11100000
11000000
00000000
NAME popup 82

TIL 2k
00011111
00001111
00001111
00001111
00000001
00000000
00000000
00000000
NAME popup 83

TIL 2l
11110001
11110001
11110000
11110000
11111000
00010000
00000000
00000000
NAME popup 84

TIL 2m
11111111
11111111
11111111
11111111
01111111
01111111
01111111
00111111
NAME popup 85

TIL 2n
11111111
11111111
11111111
11111111
11111111
11111110
11111000
11100000
NAME popup 86

TIL 2o
11110000
11100000
11000000
11000001
00000011
00000011
00000111
00000111
NAME popup 87

TIL 2p
00111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 88

TIL 2q
01111111
01111111
00111111
00111111
00011111
00001111
00001111
00001111
NAME popup 89

TIL 2r
11100001
11110000
11110000
11111000
11111000
11111100
11111110
11111110
NAME popup 90

TIL 2s
11111111
11111111
11111111
01111111
00111111
00111111
00011111
00001111
NAME popup 91

TIL 2t
00000000
00000000
11000000
11000000
11000001
11000000
11000111
11000111
NAME popup 92

TIL 2u
00000000
00000000
00001110
00111111
11111111
11111111
11111111
11111111
NAME popup 93

TIL 2v
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 94

TIL 2w
00000000
00000000
00000000
00001101
00000001
11110010
11000011
10000111
NAME popup 95

TIL 2x
00000000
00000000
01010000
11111110
11111110
11111111
11111111
11111111
NAME popup 96

TIL 2y
00000000
00000000
00000000
00000000
10000000
11000000
11100000
11110000
NAME popup 97

TIL 2z
00111111
00111111
00111111
00111110
00111110
01111000
01111000
01111000
NAME popup 98

TIL 3a
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000011
NAME popup 109

TIL 3b
01111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup 110

TIL 3c
00000111
00000111
00000011
00000011
00000011
00000000
00000000
00000000
NAME popup 111

TIL 3d
11111100
11111110
11111110
11111110
11111111
11111111
11111111
11111111
NAME popup 112

TIL 3e
00000001
00000001
00000001
00000000
00000000
10000000
11000000
11000000
NAME popup 113

TIL 3f
11100000
11111110
11111110
11111110
11111110
00111111
00011111
00001111
NAME popup 114

TIL 3g
00000000
00000000
00000000
00000000
00000000
01000000
11110000
11110000
NAME popup 115

TIL 3h
11111111
11111111
01111111
00111111
00011111
00011111
00001111
00001111
NAME popup 116

TIL 3i
11111111
11111111
11111111
11111111
11111110
11111110
11111100
11110000
NAME popup 117

TIL 3j
11000000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME popup 118

TIL 3k
00000111
00000111
00001111
00001111
00011111
00011111
00111110
01111110
NAME popup 119

TIL 3l
10000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME popup 120

TIL 3m
00000011
00000111
00000111
00000111
00000111
00000111
00001111
00001111
NAME popup 121

TIL 3n
11111111
11111111
01111111
01111111
01111111
01111111
01111111
00111111
NAME popup 122

TIL 3o
11100000
11100000
11100000
11110000
11110000
11110000
11111000
11111000
NAME popup 123

TIL 3p
00000111
00000111
00000011
00000011
00000001
00000000
00000000
00000000
NAME popup 124

TIL 3q
11111000
11111000
11111000
11111100
11111111
11111111
11111111
01111111
NAME popup 125

TIL 3r
00000111
00000011
00000001
00000000
00000000
10011100
11111111
11111111
NAME popup 126

TIL 3s
11100111
11100000
11100000
00000000
00000000
00000000
10000000
11111111
NAME popup 127

TIL 3t
11100000
00000000
00000000
00000000
00000000
01111000
11111101
11111111
NAME popup 128

TIL 3u
00000000
00000001
00000011
00000111
00001111
01111111
11111111
11111111
NAME popup 129

TIL 3v
11111110
11111110
11111110
11111110
11111110
11111110
11111100
11111100
NAME popup 130

TIL 3w
00001111
00011111
00011111
00111111
00111111
01111111
11111111
11111111
NAME popup 131

TIL 3x
00111111
00111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME popup 132

TIL 3y
11111000
11111000
11111100
11111100
11111100
11111110
11111110
11111110
NAME popup 133

TIL 3z
01111111
01111111
00111111
00011111
00001111
00000001
00110000
01111111
NAME popup 134

TIL 4a
11111110
11111100
11111100
11111000
11110000
11110000
11110000
11100000
NAME popup 145

TIL 4b
00000111
00000111
00000111
00000111
00000001
00000000
00000000
00000000
NAME popup 146

TIL 4c
11101111
11111111
11111111
11111111
11111111
01111111
00011111
00001111
NAME popup 147

TIL 4d
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11110000
NAME popup 148

TIL 4e
11110000
11110000
11110000
11100000
11000000
10000000
00000000
00000000
NAME popup 149

TIL 4f
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME popup 150

TIL 4g
11111111
11111111
01111111
00011111
00001111
00001111
00000111
00000111
NAME popup 151

TIL 4h
00000000
00000000
00000000
00011111
00010000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME z-tl

TIL 4i
00000000
00000000
00000000
11110000
00010000
00100000
01000000
10000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME z-tr

TIL 4j
00000001
00000010
00000100
00001000
00011111
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME z-bl

TIL 4k
00000000
00000000
00000000
00010000
11110000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME z-br

TIL 4l
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00011111
00010000
00000000
00000000
00000000
NAME z-tl2

TIL 4m
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
11110000
00010000
00100000
01000000
10000000
NAME z-tr2

TIL 4n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000001
00000010
00000100
00001000
00011111
00000000
00000000
00000000
NAME z-bl2

TIL 4o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00010000
11110000
00000000
00000000
00000000
NAME z-br2

TIL 4p
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass

TIL 4q
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110
NAME bear 1

TIL 4r
11111111
11111111
11111111
11100001
10000000
00000000
00000000
00000001
NAME bear 2

TIL 4s
11111111
11111111
11111111
11001111
10000011
10000001
00000001
00000000
NAME bear 3

TIL 4t
11111110
11111100
11111111
11111111
11111111
11111111
11101111
11111110
NAME bear 4

TIL 4u
00001100
01101000
11000000
11100000
10110100
11010000
11101000
01000000
NAME bear 5

TIL 4v
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111100
NAME bear 6

TIL 4w
11111111
11111111
10101000
10000000
00100000
10000000
01000000
00000000
NAME bear 7

TIL 4x
11111111
11111111
01111111
00001111
00011111
00011111
00111111
00111111
NAME bear 8

TIL 4y
01111111
11111111
10111111
11111110
11110100
11101000
11110000
11110100
NAME bear 9

TIL 4z
01000000
10000000
10000000
00000100
01110101
01000000
00000000
00000000
NAME bear 10

TIL 5a
11111111
11111111
11111111
11111111
10111111
00001111
00101110
10000111
NAME bear 21

TIL 5b
11111100
11111100
11110110
11111100
11111010
11100110
11110100
11011010
NAME bear 22

TIL 5c
01011111
11110110
11111100
01011001
10110011
10101101
00010100
00101010
NAME bear 23

TIL 5d
11110100
11101111
11010000
11111110
11111110
11100100
00000001
00000000
NAME bear 24

TIL 5e
11101111
00110111
00000111
11001001
11001001
10011011
00100111
00001101
NAME bear 25

TIL 5f
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME bear 26

TIL 5g
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear 27

TIL 5h
11111111
11111111
11111111
01111111
00111111
00111111
00011111
00011111
NAME bear 28

TIL 5i
11000000
10000000
11000000
10000000
10000000
10000000
10000011
11000100
NAME bear 29

TIL 5j
01001111
01110110
11111101
01111111
00101110
10111100
01111101
10111010
NAME bear 30

TIL 5k
00010011
10000110
10100100
00100001
10110101
00101000
01000110
10001110
NAME bear 31

TIL 5l
00000110
00000111
10000000
00000000
01000111
00001000
01010000
00001010
NAME bear 32

TIL 5m
10010000
00100000
00100000
01010100
00010010
00000100
00000001
00000001
NAME bear 33

TIL 5n
00000100
11110101
00010000
00000000
00010011
10000011
00101011
11001001
NAME bear 34

TIL 5o
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000000
NAME bear 35

TIL 5p
00001000
00001000
00001000
00001000
00001000
00011000
00011000
00011000
NAME bear 36

TIL 5q
00001111
00001111
00001111
00001111
00001111
00000111
00000111
00000011
NAME bear 37

TIL 5r
11110010
11111111
11111001
11111101
11111101
11111101
11101110
11110010
NAME bear 38

TIL 5s
11110111
11011110
11101111
00111011
10101111
01111111
11011101
01101111
NAME bear 39

TIL 5t
10000000
11011010
11111110
11111000
10110110
11001111
11110110
11001101
NAME bear 40

TIL 5u
00001000
00000111
11011011
01011111
10110011
01110100
11110100
11100011
NAME bear 41

TIL 5v
00001100
00000001
01000011
01101111
11000111
11100010
00000111
00000001
NAME bear 42

TIL 5w
01011001
10111001
11100001
01100001
01000100
00000100
10100011
00100000
NAME bear 43

TIL 5x
00000000
00010000
00001000
00001000
10001100
10000100
01000000
01000000
NAME bear 44

TIL 5y
00000000
00000000
00000000
00000000
00000000
10000000
00000000
10100000
NAME bear 45

TIL 5z
00010000
00110000
01000000
01100000
00100000
00100000
00010000
10010000
NAME bear 46

TIL 6a
10100000
10100000
01010100
11100000
00000010
01000000
00000001
00000010
NAME bear 57

TIL 6b
00000011
00000011
00000011
00000001
00000001
00000001
00000000
00000001
NAME bear 58

TIL 6c
11111110
11111111
11111111
11111011
11101100
11011001
01111110
11111010
NAME bear 59

TIL 6d
10111000
11110100
01110101
10111110
11111000
11111100
11111101
11101100
NAME bear 60

TIL 6e
01000111
10000001
00000001
01011100
01100010
00000100
00011000
00100010
NAME bear 61

TIL 6f
10101000
10101100
11010000
11111000
01110100
01010101
01001000
00001001
NAME bear 62

TIL 6g
10001100
00010000
01101000
00000100
00000000
00000101
00000000
01100010
NAME bear 63

TIL 6h
10100001
10001000
01101011
00111001
00101001
00101010
10101001
00010101
NAME bear 64

TIL 6i
00101001
11100001
00100101
11000010
10100011
01010100
10000011
00010000
NAME bear 65

TIL 6j
00001100
00000001
11000000
10100000
10100000
00100000
01000000
10000000
NAME bear 66

TIL 6k
00001000
00001000
01000100
00011111
00000000
00000000
00000000
00000000
NAME bear 67

TIL 6l
00000010
11000110
00100110
11111110
11110000
00000000
00000000
00000000
NAME bear 68

TIL 6m
00000001
00000000
00000001
00000001
00000011
00000001
00000001
00000001
NAME bear 69

TIL 6n
10110100
11110100
10101100
11010001
10111011
10100001
10100001
10000010
NAME bear 70

TIL 6o
11011111
00110110
01011101
00001111
01111111
00101110
00001110
01010000
NAME bear 71

TIL 6p
00000000
10000111
01000001
00000000
00001000
11100000
11100000
10100000
NAME bear 72

TIL 6q
00010001
00001110
00000011
11000000
00000110
00100100
00100000
00110001
NAME bear 73

TIL 6r
01000001
00000000
10000010
00000001
01000000
00000000
10010100
10010000
NAME bear 74

TIL 6s
10111010
00001100
00010101
01001110
00100001
00000100
00101010
00010000
NAME bear 75

TIL 6t
10100000
11001100
00101011
01110110
10000000
11001010
01110000
10001000
NAME bear 76

TIL 6u
00100000
01000000
00011000
00110100
00001100
10000000
00000000
00011100
NAME bear 77

TIL 6v
00000000
00000000
00000000
00000000
00000000
10000000
00010000
00000000
NAME bear 78

TIL 6w
00000001
00000001
00000011
00000000
00000000
00000000
00000001
00000001
NAME bear 79

TIL 6x
01010011
10000000
01010000
10100100
11100001
10000000
10000100
11100010
NAME bear 80

TIL 6y
00010110
10000010
00000000
00010000
00000000
10101010
00000000
00000000
NAME bear 81

TIL 6z
00001100
00110100
11000101
11110101
00000100
01000000
00000110
00000000
NAME bear 82

TIL 7a
00000000
00000000
00000000
01000000
00000000
00000000
00100010
00000000
NAME bear 93

TIL 7b
00110000
00110100
00001100
00000000
10000000
00000000
00000000
00000000
NAME bear 94

TIL 7c
00000010
00000000
00000000
00100001
00000000
00000000
10000000
00000101
NAME bear 95

TIL 7d
10010100
11000100
00000110
00000100
00000100
00000100
00000000
00010000
NAME bear 96

TIL 7e
01001000
01001000
00001000
00000000
00000000
01000010
00000000
10010000
NAME bear 97

TIL 7f
00000011
00000000
00000000
00000000
00000000
00000010
00000000
00000001
NAME bear 98

TIL 7g
10101000
11010000
00000000
00010000
10000000
01000000
00000000
00010000
NAME bear 99

TIL 7h
00001111
00001011
00001111
00001111
00101111
00111111
01111111
01111111
NAME bear 100

TIL 7i
11111100
11111100
11111110
11111110
11111111
11111111
11111111
11111111
NAME bear 101

TIL 7j
00000000
00000000
01000000
01100000
10100000
10100000
10100000
11110000
NAME bear 102

TIL 7k
00000000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear 103

TIL 7l
00000000
00000000
00000000
00100000
00000010
00000000
00000000
00000000
NAME bear 104

TIL 7m
10001000
00000101
00000101
00000000
00000100
00000000
00000000
00000000
NAME bear 105

TIL 7n
01000000
00100000
00000000
00000000
10000000
00000000
10000000
00000000
NAME bear 106

TIL 7o
00000001
00000000
00010000
00000000
00000000
00000000
00000000
00000000
NAME bear 107

TIL 7p
10000000
01000000
10000000
00000000
11100000
00000000
01000000
00000000
NAME bear 108

TIL 7q
00000000
00000000
00000100
00000111
00000111
00001011
00000111
00111111
NAME bear 109

TIL 7r
11010000
11110000
11111111
11111101
11111101
11111111
11111111
11111111
NAME bear 110

TIL 7s
00000000
00000000
00000000
10000000
10000000
10100000
10110000
11110000
NAME bear 111

TIL 7t
00000000
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear 112

TIL 7u
00000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME bear 113

TIL 7v
00000000
00000001
00000001
00000001
00000001
00000111
00100111
10101111
NAME bear 114

TIL 7w
10101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear 115

TIL 7x
11111010
11111010
11111011
11111011
11111111
11111111
11111111
11111111
NAME bear 116

TIL 7y
00000000
11000000
01000000
11110000
11110111
11111111
11111111
11111111
NAME bear 117

TIL 7z
00000000
00000000
00000000
00000000
00010000
00000010
11101101
11000110
NAME bear 118

TIL 8a
11111111
11111111
10101000
10000000
00000000
10000000
01000000
00000000
NAME bear 129

TIL 8b
11111111
11111111
01111111
00001111
00011111
00011111
00111111
00011111
NAME bear 130

TIL 8c
01000000
10000000
10000000
00000100
01010101
01000000
00000000
00000000
NAME bear 131

TIL 8d
00000000
00000000
00000000
00000000
00000000
01000000
00000000
00000000
NAME bear 132

TIL 8e
11111111
11111111
11111111
11111111
11111111
11110110
11111100
11111100
NAME bear 133

TIL 8f
11011110
11111110
10101010
01011110
01111111
10010111
00111110
11111101
NAME bear 134

TIL 8g
00000000
00000000
00000000
01010000
00101000
11000010
01001000
10011000
NAME bear 135

TIL 8h
01101111
00111111
00111111
10110111
00111111
01011111
01111101
01101011
NAME bear 136

TIL 8i
11101100
11101100
11001100
11000100
10000100
10000000
00000000
00000000
NAME bear 137

TIL 8j
00010000
00011000
00001000
00001000
00001000
00000000
01000000
00000000
NAME bear 138

TIL 8k
11111111
11111111
11111111
11111111
11101001
11110000
11000000
11110000
NAME bear 139

TIL 8l
11111111
11111111
11111111
11111111
10111111
00001101
00101110
10000111
NAME bear 140

TIL 8m
11111100
11111100
11110000
11110100
11111010
11100110
11110000
11001000
NAME bear 141

TIL 8n
01011111
11110110
11111100
01011001
10010011
10101101
00000100
00000000
NAME bear 142

TIL 8o
01110100
01101011
11010000
10111110
10110110
10000000
00000000
00000000
NAME bear 143

TIL 8p
11101111
00100111
00000111
00000001
11001001
00011011
00100111
00001101
NAME bear 144

TIL 8q
11000000
10000000
10000000
10000000
10000000
10000000
10000001
11000000
NAME bear 145

TIL 8r
01001111
00010110
10111101
01111111
00101110
10111100
01111001
00111010
NAME bear 146

TIL 8s
00010011
10000110
10100100
00000001
10110000
00101000
00000110
10001000
NAME bear 147

TIL 8t
00000000
00000100
10000000
00000000
01000001
00001000
00010000
00001000
NAME bear 148

TIL 8u
10000000
00100000
00100000
00010100
00010000
00000000
00000000
00000001
NAME bear 149

TIL 8v
00000000
10110100
00010000
00000000
00000001
10000001
00001001
00001001
NAME bear 150

TIL 8w
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME bear 151

TIL 8x
11110010
11111111
11111001
11111101
11111101
11110101
11101110
11110010
NAME bear 152

TIL 8y
11110011
11011110
11101111
00111011
10101111
01101111
01010101
01101011
NAME bear 153

TIL 8z
10000000
11011010
11111100
11011000
10110110
11001101
11110110
10001101
NAME bear 154

TIL 9a
00000000
00000001
10000000
00000000
00000000
00000000
00000000
10010000
NAME bear 165

TIL 9b
10100000
10100000
00010100
11100000
00000010
01000000
00000000
00000010
NAME bear 166

TIL 9c
11101110
11111111
11111011
11111001
10101000
11011001
01111110
11101010
NAME bear 167

TIL 9d
10111000
11100000
01110100
10111100
10011000
11111100
11111101
11101100
NAME bear 168

TIL 9e
01000111
00000001
00000001
01000100
00000000
00000000
00001000
00100000
NAME bear 169

TIL 9f
10101000
10101100
11010000
11111000
01110000
01010100
00001000
00000000
NAME bear 170

TIL 9g
10001100
00010000
01001000
00000100
00000000
00000101
00000000
00100010
NAME bear 171

TIL 9h
00100001
10000000
01100011
00011001
00100001
00101010
10001001
00010100
NAME bear 172

TIL 9i
00001001
00100001
00000101
10000000
00000000
00000000
00000011
00000000
NAME bear 173

TIL 9j
00000100
00000001
11000000
00100000
10000000
00000000
01000000
10000000
NAME bear 174

TIL 9k
10110100
11110100
10101000
10010001
10101011
10100000
10100000
00000010
NAME bear 175

TIL 9l
10011111
00100110
01011100
00001111
01010011
00001110
00000110
01010000
NAME bear 176

TIL 9m
00000000
00000101
01000001
00000000
00001000
11100000
10100000
00100000
NAME bear 177

TIL 9n
00010000
00000100
00000010
11000000
00000010
00000100
00100000
00100000
NAME bear 178

TIL 9o
01000001
00000000
00000010
00000001
00000000
00000000
00010100
10000000
NAME bear 179

TIL 9p
10111010
00001100
00010101
01001110
00000001
00000100
00001010
00010000
NAME bear 180

TIL 9q
10100000
11001100
00101010
01110110
00000000
10000010
00100000
10001000
NAME bear 181

TIL 9r
00100000
00000000
00001000
00110100
00000000
00000000
00000000
00011000
NAME bear 182

TIL 9s
00000000
00000000
00000000
00000000
00000000
10000000
00000000
00000000
NAME bear 183

TIL 9t
00000000
00000001
00000010
00000000
00000000
00000000
00000000
00000001
NAME bear 184

TIL 9u
00010010
10000000
00000000
10100100
11100000
00000000
10000000
11000000
NAME bear 185

TIL 9v
00000010
10000000
00000000
00010000
00000000
00100000
00000000
00000000
NAME bear 186

TIL 9w
00001100
00110100
10000101
01110101
00000100
00000000
00000000
00000000
NAME bear 187

TIL 9x
00100000
00100000
00000000
00000000
01000000
01000000
00001000
00000000
NAME bear 188

TIL 9y
10000000
00000001
00000000
00100000
00000011
00000001
00000001
00000001
NAME bear 189

TIL 9z
00001000
00000000
10000000
10000000
00000000
00000001
10100001
10001101
NAME bear 190

TIL a0
00000000
00000000
00000000
00000000
00100101
10000100
00000000
11001010
NAME bear 191

TIL a1
00000000
00000000
00000000
00000000
00000000
00001000
00000010
00000111
NAME bear 192

TIL a2
00000000
00000000
00000000
00000000
00000010
00000000
00000010
00010000
NAME bear 193

TIL a3
00000001
00000001
00000011
00000011
00000001
00000101
00000001
00000011
NAME bear 194

TIL a4
11000001
10000000
11000000
11100000
11001000
11001100
11111100
11111010
NAME bear 195

TIL a5
00000000
00001000
00001000
00000000
00001000
00000010
00000000
00000000
NAME bear 196

TIL a6
00010000
00000100
00000100
00000000
00000000
00000000
00000000
00000000
NAME bear 197

TIL a7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME bear 198

TIL a8
10010100
01000100
00000110
00000100
00000100
00000100
00000000
00010000
NAME bear 199

TIL a9
01001000
00001000
00001000
00000000
00000000
00000000
00000000
10010000
NAME bear 200

TIL aa
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear 201

TIL ab
10101000
11010000
00000000
00000000
10000000
01000000
00000000
00010000
NAME bear 202

TIL ac
00000000
00000000
01000000
01100000
10100000
10100000
10100000
11000000
NAME bear 203

TIL ad
00000000
00000000
00000000
00100000
00000000
00000000
00000000
00000000
NAME bear 204

TIL ae
00001000
00000101
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear 205

TIL af
10000000
01000000
10000000
00000000
01100000
00000000
00000000
00000000
NAME bear 206

TIL ag
00000000
00000000
00000100
00000101
00000111
00001011
00000111
00111111
NAME bear 207

TIL ah
00000000
00000000
00000000
00000000
10000000
10100000
10100000
11110000
NAME bear 208

TIL ai
00000000
00000000
00000001
00000001
00000001
00000111
00100111
10101111
NAME bear 209

TIL aj
10101111
11111111
11111111
01111111
11111111
11111111
11111111
11111111
NAME bear 210

TIL ak
00000000
11000000
01000000
11110000
11110101
11110110
11110111
11111111
NAME bear 211

TIL al
00000000
00000000
00000000
00000000
00010000
00000010
11001101
11000110
NAME bear 212

TIL am
00000000
00000000
00000000
00000000
00000000
00000000
00000010
11010010
NAME bear 213

TIL an
01000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME bear 214

TIL ao
00000000
00000010
00000001
00001011
00011111
01110111
10111111
11111111
NAME bear 215

TIL ap
11101111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear 216

TIL aq
11100100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear 217

TIL ar
00000000
01000000
11111000
11111001
11111011
11111111
11111111
11111111
NAME bear 218

TIL as
00100011
00100111
00101111
01111111
10111111
11111111
11111111
11111111
NAME bear 219

TIL at
00000000
00000000
00000000
00001110
00001110
00001110
00001110
00001110
NAME grave 1

TIL au
00000000
00000000
00000000
00111111
00111111
00111111
00000000
00000000
NAME grave 2

TIL av
00001110
00001110
00001110
11111111
11111111
11111111
00011111
00011110
NAME grave 3

TIL aw
00000000
00000000
00000000
11111111
11111111
11111111
11111111
00000000
NAME grave 4

TIL ax
00001110
00011110
00011110
00011110
00011110
00011110
00011110
00011110
NAME grave 5

TIL ay
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000110
NAME grave 6

TIL az
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01011111
NAME grave 7

TIL b0
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111100
NAME grave 8

TIL b1
00011110
00011100
00011100
00011100
00011100
00011100
00011100
00011100
NAME grave 9

TIL b2
00000000
00000000
00011011
00110010
11111111
11111111
11111111
11111111
NAME grave 10

TIL b3
00001110
00011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 11

TIL b4
10011111
11111101
11111111
11111111
11111111
11111111
10111111
11111111
NAME grave 12

TIL b5
11111110
11111111
11111111
11111111
11111110
11111111
01011111
11111101
NAME grave 13

TIL b6
00111100
10111110
11111111
11111111
11110001
11111000
11111101
11110111
NAME grave 14

TIL b7
00000000
10000000
11010000
11110000
11111110
11111111
11111111
11111111
NAME grave 15

TIL b8
00000000
00000000
00000000
00000000
00000000
10000000
10000000
00000000
NAME grave 16

TIL b9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME grave 17

TIL ba
00000000
00000000
00000000
00000001
00001111
00011011
01111110
10111111
NAME grave 18

TIL bb
00000000
00000011
00111111
11111111
11111011
11111111
11111111
11111111
NAME grave 19

TIL bc
10011111
11111111
10111111
01111111
11111111
11111110
11111111
11110001
NAME grave 20

TIL bd
01100111
10111111
11111101
11010000
11001111
11111111
11111111
11111111
NAME grave 21

TIL be
11111111
11111111
11111111
01111111
11111111
11111111
11111111
11110111
NAME grave 22

TIL bf
11111111
11111111
11100111
00111011
11111111
11111011
00000111
10010111
NAME grave 23

TIL bg
11011011
11100011
11100111
11111111
11111001
10110110
11111111
00110111
NAME grave 24

TIL bh
11111001
11111110
11111110
10011010
00001111
00011111
01110111
11110010
NAME grave 25

TIL bi
11111111
00001111
00000101
01111100
11100000
01000000
11010000
01000000
NAME grave 26

TIL bj
11100000
11100000
01100000
00110000
01110000
01110000
00100000
11100000
NAME grave 27

TIL bk
00000000
00000000
00000000
00000001
00000011
00000111
00001111
00001111
NAME grave 28

TIL bl
00000111
00011111
01101101
11111111
11111111
11111111
11111111
11111111
NAME grave 29

TIL bm
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 30

TIL bn
11111111
11111111
11111111
11111111
11111111
01111100
11111100
11100100
NAME grave 31

TIL bo
11110000
11000101
11100111
11100111
11111111
10101111
11100111
11110110
NAME grave 32

TIL bp
11101111
11011011
11111111
11111111
11111101
11111111
11111000
01111000
NAME grave 33

TIL bq
11111111
11111111
11110111
11111111
11001000
11000010
11110101
11111011
NAME grave 34

TIL br
00001111
11001111
11001111
10000111
00000011
00000000
11100111
10001111
NAME grave 35

TIL bs
11111111
10000001
10000000
11110000
11010000
11111000
11111000
10100000
NAME grave 36

TIL bt
10111000
11011000
11110000
11010000
00000000
00001000
00101111
00010111
NAME grave 37

TIL bu
00000000
00000000
00001001
00001001
00001001
01111101
11100110
01111111
NAME grave 38

TIL bv
10110000
10010000
10110000
10110000
11100000
01000000
10000000
00000000
NAME grave 39

TIL bw
00000000
00000000
00000011
00000011
00000110
00011111
01111001
11111111
NAME grave 40

TIL bx
00011111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 41

TIL by
11111111
11111111
11111111
11111111
11111110
11111011
11011111
11110111
NAME grave 42

TIL bz
10001000
10011000
10110100
10111101
10101110
11111100
11011100
11001111
NAME grave 43

TIL c0
01111100
11111110
11111111
01111111
10111111
11111111
11111111
11111111
NAME grave 44

TIL c1
00000011
00000101
00001111
00001111
00001101
11011100
11110000
11101110
NAME grave 45

TIL c2
10110011
01111101
10111111
11000111
11001111
11000011
11001111
01111111
NAME grave 46

TIL c3
11101101
10100100
10100000
11111000
10111110
11111000
11110000
11111000
NAME grave 47

TIL c4
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME grave 48

TIL c5
00010111
00011011
00111111
00011111
00011110
00000000
00000000
00000000
NAME grave 49

TIL c6
10111100
10110000
11000000
00000000
00000000
00000000
00000000
00000000
NAME grave 50

TIL c7
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME grave 51

TIL c8
11111111
11111111
11111111
11111110
11011111
11001101
11111111
11111111
NAME grave 52

TIL c9
11111111
11111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME grave 53

TIL ca
11111111
11111111
11111111
11111111
11111111
11111011
11110111
11111111
NAME grave 54

TIL cb
11110111
11111111
11111111
11110011
11111001
11110011
11111111
11111111
NAME grave 55

TIL cc
11111111
00011111
11111111
11111110
11111101
11111111
11110011
11110101
NAME grave 56

TIL cd
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111101
NAME grave 57

TIL ce
10111011
11111111
11110111
11111111
11110111
11110001
11110000
11111111
NAME grave 58

TIL cf
01111110
01100101
00000011
00000001
11111101
11110010
01111111
11111100
NAME grave 59

TIL cg
11111000
11111000
01101100
11111010
11101111
11100110
10111000
10111000
NAME grave 60

TIL ch
01111111
11111111
11111111
11110011
00011111
00011111
00111000
00011110
NAME grave 61

TIL ci
11111111
11111111
11111111
11111111
10111110
11111010
11111011
11111101
NAME grave 62

TIL cj
11111111
01111011
11111111
00011111
11111111
11111111
01111011
11100111
NAME grave 63

TIL ck
11110111
11111111
11111111
11111111
11111111
10111111
11011011
10111111
NAME grave 64

TIL cl
11111111
11101111
01111111
11111111
11111110
10001111
10011111
01111111
NAME grave 65

TIL cm
11111111
11111111
11111111
11111111
10111110
10111111
11101111
11111111
NAME grave 66

TIL cn
11111111
11011111
10110110
11111111
11110111
11111111
10101101
10101110
NAME grave 67

TIL co
01111000
11111111
00111111
11110100
01111000
01110000
11000000
00000000
NAME grave 68

TIL cp
00001101
00000111
00000011
00000011
00000001
00000000
00000000
00000000
NAME grave 69

TIL cq
10111110
11110001
11110011
11100000
11100000
00000000
00000000
00000000
NAME grave 70

TIL cr
11101111
11101101
11100011
10000111
00000011
00000110
00000000
00000000
NAME grave 71

TIL cs
10101111
11001111
11101111
00001111
00001110
00000011
00000011
00000011
NAME grave 72

TIL ct
11011111
00000011
00000011
00000010
11000010
11110001
11110000
11110000
NAME grave 73

TIL cu
01011101
10011100
10011110
01011100
01100000
10000000
00000000
00000000
NAME grave 74

TIL cv
10110000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME grave 75

TIL cw
11111111
11111111
11111111
11100001
11100001
11100001
11100001
11100001
NAME grave 76

TIL cx
11111111
11111111
11111111
11000000
11000000
11000000
11000000
11111111
NAME grave 77

TIL cy
11100001
11100001
11100001
00000000
00000000
00000000
00000000
11100001
NAME grave 78

TIL cz
11111111
11111111
11111111
00000000
00000000
00000000
00000000
11111111
NAME grave 79

TIL d0
11100001
11100001
11100001
11100001
11100001
11100001
11100001
11100001
NAME grave 80

TIL d1
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111001
NAME grave 81

TIL d2
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10100000
NAME grave 82

TIL d3
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000011
NAME grave 83

TIL d4
11100001
11100001
11100001
11100001
11100001
11100001
11100001
11100001
NAME grave 84

TIL d5
11111111
11111111
11111111
11111111
11111111
11111111
11111000
11111000
NAME grave 85

TIL d6
11111111
11111111
11100100
11001101
00000000
00000000
00000000
00000000
NAME grave 86

TIL d7
11110001
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME grave 87

TIL d8
01000000
00000010
00000000
00000000
00000000
00000000
01000000
00000000
NAME grave 88

TIL d9
00000000
00000000
00000000
00000000
00000001
00000000
10100000
00000010
NAME grave 89

TIL da
11000011
01000001
00000000
00000000
00001110
00000111
00000010
00001000
NAME grave 90

TIL db
11111111
01111111
00101111
00001111
00000001
00000000
00000000
00000000
NAME grave 91

TIL dc
11111111
11111111
11111111
11111111
11111111
01111111
01111111
11111111
NAME grave 92

TIL dd
11111111
11111111
11111111
11111100
11110000
11100100
10000001
00000000
NAME grave 93

TIL de
11111111
11111000
11000000
00000000
00000100
00000000
00000000
00000000
NAME grave 94

TIL df
01100000
00000000
00000000
10000000
00000000
00000001
00000000
00001110
NAME grave 95

TIL dg
10011000
01000000
00000010
00001111
00110000
00000000
00000000
00000000
NAME grave 96

TIL dh
00000000
00000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME grave 97

TIL di
00000000
00000000
00011000
01000100
00000000
00000100
01111000
01101000
NAME grave 98

TIL dj
00100100
00011100
00011000
00000000
00000110
01000001
00000000
11001000
NAME grave 99

TIL dk
00000110
00000001
00000001
01100101
11110000
11100000
10001000
00001101
NAME grave 100

TIL dl
00000000
11110000
11111000
10000011
00011111
00011111
00101111
10111111
NAME grave 101

TIL dm
00011111
00011111
10011111
11001111
10001111
10001111
11011111
00011111
NAME grave 102

TIL dn
11111111
11111111
11111111
11111110
11111100
11111000
11110000
11110000
NAME grave 103

TIL do
11111000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME grave 104

TIL dp
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME grave 105

TIL dq
00000000
00000000
00000000
00000000
00000000
00000011
00000011
00011011
NAME grave 106

TIL dr
00001111
00111010
00011000
00011000
00000000
01010000
00011000
00001000
NAME grave 107

TIL ds
00010000
00000100
00000000
00000000
00000010
00000000
00000110
00000111
NAME grave 108

TIL dt
00000000
00000000
00001000
00000000
00110111
00111101
00000010
00000100
NAME grave 109

TIL du
11110000
00110000
00110000
01111000
11111100
11111111
00011000
01110000
NAME grave 110

TIL dv
00000000
01111110
01111111
00001111
00101111
00000111
00000111
01011111
NAME grave 111

TIL dw
01000111
00100111
00001111
00101111
11111111
11110111
11010000
11101000
NAME grave 112

TIL dx
11111111
11111111
11110110
11110110
11110110
10000010
00001000
10000000
NAME grave 113

TIL dy
01001111
01101111
01000111
01001111
00001111
10111111
01111111
11111111
NAME grave 114

TIL dz
11111111
11111111
11111100
11111000
11111001
11100000
10000110
00000000
NAME grave 115

TIL e0
11000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME grave 116

TIL e1
00000000
00000000
00000000
00000000
00000001
00000100
00100000
00000000
NAME grave 117

TIL e2
01110111
01100110
01001011
01000010
01010001
00000011
00000011
00110000
NAME grave 118

TIL e3
10000011
00000001
00000000
10000000
01000000
00000000
00000000
00000000
NAME grave 119

TIL e4
11111100
11111010
11110000
11110000
11110010
00100011
00001111
00010001
NAME grave 120

TIL e5
00001000
10000010
01000000
00011000
00110000
00111100
00110000
10000000
NAME grave 121

TIL e6
00010010
00011011
01011111
00000111
01000001
00000111
00001111
00000111
NAME grave 122

TIL e7
00111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 123

TIL e8
11101000
11100000
11000000
11100000
11100001
11111111
11111111
11111111
NAME grave 124

TIL e9
01000011
01000111
00111111
11111111
11111111
11111111
11111111
11111111
NAME grave 125

TIL ea
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111111
NAME grave 126

TIL eb
00000000
00000000
00000000
00000001
00000000
00110010
00000000
00000000
NAME grave 127

TIL ec
00000000
00000000
00000000
00000000
00000000
00000100
00000000
00000000
NAME grave 128

TIL ed
00001000
00000000
00000000
00001000
00000110
00001100
00000000
00000000
NAME grave 129

TIL ee
00000000
10100000
00000000
00000001
00000010
00000000
00001100
00001010
NAME grave 130

TIL ef
00000000
00000000
00001000
00000000
00000000
00001110
00001111
00000000
NAME grave 131

TIL eg
10000000
10001010
11111100
11111110
00000010
00000101
10000000
00000011
NAME grave 132

TIL eh
00000111
00000111
10010001
00000001
00000000
00011001
01000111
01000111
NAME grave 133

TIL ei
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 134

TIL ej
10000000
00000000
00000000
00001100
11100000
11100000
11000111
11100001
NAME grave 135

TIL ek
00000000
00000000
00000000
00000000
01000000
00000101
00000100
00000010
NAME grave 136

TIL el
00000000
10000100
00000000
11100000
00000000
00000000
10000100
00011000
NAME grave 137

TIL em
00001000
00000000
00000000
00000000
00000000
01000000
00100100
01000000
NAME grave 138

TIL en
00000000
00000000
10000000
00000000
00000001
01100000
01100000
10000000
NAME grave 139

TIL eo
00000000
00000000
00000000
00000000
01000001
01000000
00010000
00000000
NAME grave 140

TIL ep
00000000
00100000
01001001
00000000
00001000
00000000
01010010
01010001
NAME grave 141

TIL eq
10000111
00000000
11000000
00000001
10000111
10001111
00111111
11111111
NAME grave 142

TIL er
11000111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 143

TIL es
11110010
11111000
11111100
11111100
11111110
11111111
11111111
11111111
NAME grave 144

TIL et
01000001
00001110
00001100
00011111
00011111
11111111
11111111
11111111
NAME grave 145

TIL eu
00010000
00010010
00011100
01111000
11111100
11111001
11111111
11111111
NAME grave 146

TIL ev
01010000
00110000
00010000
11110000
11110001
11111100
11111100
11111100
NAME grave 147

TIL ew
00100000
11111100
11111100
11111101
00111101
00001110
00001111
00001111
NAME grave 148

TIL ex
10100010
01100011
01000001
10000011
10010111
01111111
11111111
11111111
NAME grave 149

TIL ey
01001111
00111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME grave 150

TIL ez
00000011
00001111
00011111
00111111
00111111
01111111
01111111
11111111
NAME bear01

TIL f0
11110000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear02

TIL f1
11000000
11110000
11111100
11111110
11111111
11111111
11111111
11111111
NAME bear03

TIL f2
00000000
00000000
00000000
00000000
10000000
11000000
11000000
11100000
NAME bear04

TIL f3
11111111
11111111
01111011
01111011
11110011
11110011
11100001
11100000
NAME bear05

TIL f4
11111111
11111111
11111111
11100111
11000111
11000111
11100011
00000001
NAME bear06

TIL f5
11111111
11111001
11111100
11111100
10111100
10011000
11100000
11100000
NAME bear07

TIL f6
11100000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bear08

TIL f7
11000001
11000001
11000001
11000001
11000001
11000001
11000001
11000001
NAME wallleft
WAL true

TIL f9
11111111
11111111
00000000
00000000
00000000
00000000
00000000
11111111
NAME wallup
WAL true

TIL fb
10000000
11000000
11100000
11010000
11001000
11000100
11000010
11000001
NAME wallur
WAL true

TIL fc
11111111
01111111
00100000
00010000
00001000
00000100
00000010
00000001
NAME walldr
WAL true

TIL fe
11000001
11000001
00100001
00010001
00001001
00000101
00000011
11111111
NAME walldl
WAL true

TIL fj
11111111
11111111
01000100
00100010
11111111
01000100
00100010
11111111
NAME walldown
WAL true

TIL fk
11001101
11101011
11011001
11001001
11001101
11101011
11011001
11001001
NAME wallright
WAL true

TIL fl
11111111
11111111
11100100
11010010
11001111
11101100
11011010
11001001
NAME wallbrickul
WAL true

TIL fm
11001101
11101011
01111001
00111001
11111101
01000111
00100011
11111111
NAME wallbrickdr
WAL true

TIL fo
11111111
01111111
00100100
00010010
00011111
00000100
01000010
00000001
NAME wallbrickdl
WAL true

TIL fp
10000000
11000100
11100010
11011000
11001000
11101100
11011010
11001001
NAME wallbrickur
WAL true

TIL fq
11111111
11111111
11100000
11010000
11001000
11000100
11000010
11000001
NAME wallul
WAL true

TIL fr
11000001
11000001
10100001
01010001
00101001
00010101
00001011
00000111
NAME wallend
WAL true

TIL fs
00000000
00000000
10101110
10100100
00100100
10100100
10100100
00000000
NAME exit3

TIL ft
00000000
01000000
00011010
00010010
00011001
00010010
01011010
00000000
NAME exit2

TIL fu
00000000
00000000
01000100
01001010
01001110
01001010
01101010
00000000
NAME laundry1

TIL fv
00000000
00000000
10101001
10101101
10101011
10101001
11101001
00000000
NAME laundry2

TIL fw
00000000
00000000
01100110
01010101
01010101
01010110
01100101
00000000
NAME laundry3

TIL fx
00000000
00000100
01010010
01010000
00100000
00100000
00100010
00000000
NAME laundry4

TIL fy
00000000
00000000
01110110
01010100
01010110
01010100
01110100
00000000
NAME office1

TIL fz
00000000
00000000
11010110
10010100
11010100
10010100
10010110
00000000
NAME office2

TIL g0
00000000
00000100
11000010
10001000
11010000
10000000
11000010
00000000
NAME office3

TIL g1
00000000
01101100
01001010
01101010
01001010
01101100
00000000
00000000
NAME bed2

TIL g2
00000000
01000110
00000101
00000110
00010101
00000110
01000000
00000000
NAME bed1

TIL g3
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME popup152

TIL g4
00000000
00000000
01001010
01001010
01001010
01001010
01101001
00000000
NAME living1

TIL g5
00000000
00000000
10101001
10101101
10101011
10101001
00101001
00000000
NAME living2

TIL g6
00000000
00000000
00110001
01000001
01010001
01010001
00110001
00000000
NAME living3

TIL g7
00000000
00000000
10011101
01010101
10010101
01010101
01011101
00000000
NAME living4

TIL g8
00000000
00000000
11011011
01010101
01010101
01010101
11010101
00000000
NAME living5

TIL g9
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bear220

SPR 10
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass114
POS a 4,13

SPR 11
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass115
POS a 12,14

SPR 12
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass21
POS b 8,1

SPR 13
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass22
POS b 8,2

SPR 14
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass23
POS b 2,3

SPR 15
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass24
POS b 10,3

SPR 16
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass25
POS b 15,4

SPR 17
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass26
POS b 6,5

SPR 18
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass27
POS b 3,7

SPR 19
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass28
POS b 11,7

SPR 20
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME blankoffice
DLG SPR_8
POS 0 0,6

SPR A
00000000
00001100
00001100
00001000
00011100
00101010
00001000
00010100
>
00000000
00001100
00001100
00001000
00011100
00101010
00001000
00010100
POS 0 4,11

SPR a
00111000
00111000
00010100
00110100
01110000
00010000
00110000
01001000
NAME mom-start
DLG SPR_0
POS 0 9,4

SPR b
00011000
00011000
01111110
10011001
10011001
00111100
00100100
01100110
NAME dad-start
DLG SPR_1
POS 0 6,4

SPR d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME office
DLG SPR_3
POS b 14,5

SPR e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME garage
DLG SPR_4
POS 0 4,15

SPR f
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME laundry
DLG SPR_5
POS 0 10,15

SPR g
00111000
00111000
00010100
00110100
01110000
00010000
00110000
01001000
NAME mom-after
DLG SPR_6
POS 2 9,4

SPR h
00011000
00011000
01111110
10011001
10011001
00111100
00100100
01100110
NAME dad-after
DLG SPR_7
POS 2 6,4

SPR i
00011000
00011000
01001010
00111100
00001000
00001000
00010100
00010100
NAME relative
DLG SPR_2
POS 8 11,5

SPR j
00000000
00000111
00001000
00001000
00001000
11111000
11111111
11111111
NAME truck-tr
POS 8 15,5

SPR k
00000000
00000000
00000000
00000000
00000000
01000000
01000000
01100001
NAME truck-tl
POS 7 1,2

SPR l
01111111
01111111
00000100
00000100
00000011
00000000
00000000
00000000
NAME truck-bl
POS 8 14,6

SPR m
11111111
11111111
01000001
01000001
10000000
00000000
00000000
00000000
NAME truck-br
POS 8 15,6

SPR n
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass11
POS a 8,1

SPR o
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass12
POS a 8,2

SPR p
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass13
POS a 2,3

SPR q
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass14
POS a 10,3

SPR r
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass15
POS a 15,4

SPR s
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass16
POS a 6,5

SPR t
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass17
POS a 11,7

SPR u
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass18
POS a 13,9

SPR v
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass19
POS a 5,10

SPR w
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass110
POS a 8,10

SPR x
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass111
POS a 11,11

SPR y
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass112
POS a 1,12

SPR z
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass113
POS a 6,12

SPR 1a
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass29
POS b 13,9

SPR 1b
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass210
POS b 5,10

SPR 1c
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass211
POS b 8,10

SPR 1d
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass212
POS b 11,11

SPR 1e
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass213
POS b 1,12

SPR 1f
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass214
POS b 6,12

SPR 1g
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass215
POS b 4,13

SPR 1h
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass216
POS b 12,14

SPR 1i
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass31
POS c 8,1

SPR 1j
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass32
POS c 8,2

SPR 1k
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass33
POS c 2,3

SPR 1l
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass34
POS c 10,3

SPR 1m
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass35
POS c 15,4

SPR 1n
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass36
POS c 6,5

SPR 1o
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass37
POS c 3,7

SPR 1p
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass38
POS c 11,7

SPR 1q
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass39
POS c 13,9

SPR 1r
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass310
POS c 5,10

SPR 1s
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass311
POS c 8,10

SPR 1t
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass312
POS c 11,11

SPR 1u
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass313
POS c 1,12

SPR 1v
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass314
POS c 6,12

SPR 1w
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass315
POS c 4,13

SPR 1x
00000010
00000100
00001000
00001001
01101010
00011100
01011011
00111100
NAME grass316
POS c 12,14

SPR 1y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME blank1
POS a 14,5

SPR 1z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME blank2
POS c 14,5

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG ITM_0

DLG SPR_0
That's a yucky movie. Don't watch that.

DLG ITM_0
You found a nice warm cup of tea

DLG SPR_1
You shouldn't watch this show. It's too old for you.

DLG SPR_3
It's too late to go on the computer. I want to see what's on TV!

DLG SPR_4
It's too late to go outside. I want to see what's on TV!

DLG SPR_5
The laundry room?! I want to see what's on TV!

DLG SPR_6
I TOLD YOU NOT TO WATCH THAT. GO TO BED. NOW.

DLG SPR_7
I TOLD YOU NOT TO WATCH THAT. GO TO BED. NOW.

DLG SPR_2
Hop in the back of the truck!

DLG SPR_8
It's too late to go on the computer. I want to see what's on TV!

END 0
You decided to go to sleep instead of watching bad TV.  Good choice...

END 1
You were snatched out of the truck by a polar bear, and it buried you alive. The end.

VAR a
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
/*
TODO:
- untangle local & external resource use in font manager (still more to do here)
*/

function FontManager(useExternalResources) {

if (useExternalResources === undefined || useExternalResources === null) {
	useExternalResources = false;
}

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data that is part of the local game data
var localResources = {};

// place to store font data fetched from a server (only used in editor)
var externalResources = null;
if (useExternalResources) {
	externalResources = new ResourceLoader();// NOTE : this class doesn't exist in exported game
}

this.LoadResources = function(filenames, onLoadAll) {
	if (!useExternalResources)
		return;

	// TODO : is this being called too many times?
	var onLoad = function() {
		var count = externalResources.getResourceLoadedCount();

		if (count >= filenames.length && onLoadAll != null) {
			onLoadAll();
		}
	}

	for (var i = 0; i < filenames.length; i++) {
		externalResources.load("bitsyfont", filenames[i], onLoad);
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	if (useExternalResources) {
		externalResources.set(filename, fontdata);
	}
	else {
		localResources[filename] = fontdata;
	}
}

this.ContainsResource = function(filename) {
	if (useExternalResources) {
		return externalResources.contains(filename);
	}
	else {
		return localResources[filename] != null;
	}
}

function GetData(fontName) {
	if (useExternalResources) {
		return externalResources.get(fontName + fontExtension);
	}
	else {
		return localResources[fontName + fontExtension];
	}
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var fontdata = {};
	var invalidCharData = [];

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return fontdata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return fontdata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (fontdata[codepoint] != null) {
			return fontdata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	function parseFont(fontData) {
		if (fontData == null)
			return;

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];
			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					fontdata[curCharCode] = [];
				}
			}
			else {
				// READING CHARACTER DATA LINE
				for (var j = 0; j < width; j++)
				{
					fontdata[curCharCode].push( parseInt(line[j]) );
				}

				curCharLineCount++;
				if (curCharLineCount >= height) {
					isReadingChar = false;
				}
			}
		}

		// init invalid character box
		invalidCharData = [];
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.push(1);
				}
				else {
					invalidCharData.push(0);
				}
			}
		}
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse( scriptStr );
		env.SetScript( scriptName, script );
	}
	this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
		// console.log("RUN");
		env.GetScript( scriptName )
			.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );

		// console.log("SERIALIZE!!!!");
		// console.log( env.GetScript( scriptName ).Serialize() );
	}
	this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var script = parser.Parse( scriptStr );
		script.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	// TODO : move to utils?
	// for reading in dialog from the larger file format
	this.ReadDialogScript = function(lines, i) {
		return parser.ReadDialogScript(lines,i);
	}

	this.Parse = function(scriptStr) { // parses a script but doesn't save it
		return parser.Parse( scriptStr );
	}
	this.Eval = function(scripTree, exitHandler) { // runs a script stored externally
		scripTree.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression( expStr );
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if(doIndentFirstLine === undefined) doIndentFirstLine = true;
		var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
		for(var i = 0; i < children.length; i++) {
			block.AddChild( children[i] );
		}
		return block;
	}

	this.ChangeSequenceType = function(oldSequence,type) {
		if(type === "sequence") {
			return new SequenceNode( oldSequence.options );
		}
		else if(type === "cycle") {
			return new CycleNode( oldSequence.options );
		}
		else if(type === "shuffle") {
			return new ShuffleNode( oldSequence.options );
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new BlockNode( BlockMode.Code );
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new BlockNode( BlockMode.Dialog );
		var result2 = new BlockNode( BlockMode.Dialog );

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new BlockNode( BlockMode.Code );
		block.AddChild( ifNode );
		return block;
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function printFunc(environment,parameters,onReturn) {
	// console.log("PRINT FUNC");
	// console.log(parameters);
	if( parameters[0] != undefined && parameters[0] != null ) {
		// console.log(parameters[0]);
		// console.log(parameters[0].toString());
		// var textStr = parameters[0].toString();
		var textStr = "" + parameters[0];
		// console.log(textStr);
		var onFinishHandler = function() {
			// console.log("FINISHED PRINTING ---- SCRIPT");
			onReturn(null);
		}; // called when dialog is finished printing
		environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment,parameters,onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing( drawingId, function() {
		onReturn(null);
	});
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
	// console.log("ITEM FUNC " + itemId + " " + itemCount);
	onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn) {
		// console.log(functionMap);
		// console.log(name);
		functionMap.get( name )( this, parameters, onReturn );
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler)
			onVariableChangeHandler(name);
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler)
				onVariableChangeHandler(name);
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];
	this.AddChild = function(node) {
		this.children.push( node );
		node.parent = this;
	};

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.children.length; i++ ) {
			this.children[i].VisitAll( visitor );
		}
	};
}

var BlockMode = {
	Code : "code",
	Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "block";
	this.mode = mode;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if( this.onEnter != null ) this.onEnter();

		var lastVal = null;
		var i = 0;
		function evalChildren(children,done) {
			if(i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval( environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this;
		evalChildren( this.children, function() {
			if( self.onExit != null ) self.onExit();
			onReturn(lastVal);
		} );
	}

	if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

	this.Serialize = function(depth) {
		if(depth === undefined) depth = 0;

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "";
		var lastNode = null;
		if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
				str += "\n";

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
				str += leadingWhitespace(depth);
			str += curNode.Serialize(depth);
			lastNode = curNode;
		}
		if (this.mode === BlockMode.Code) str += "}";
		return str;
	}
}

function isBlockWithNoNewline(node) {
	return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
				return true;
			}
		}
	}
	return false;
}

function isMultilineListBlock(node) {
	if(node.type === "block") {
		if(node.children.length > 0) {
			var child = node.children[0];
			if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
				return true;
			}
		}
	}
	return false;
}

var FuncNode = function(name,arguments) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.arguments = arguments;

	this.Eval = function(environment,onReturn) {

		if( this.onEnter != null ) this.onEnter();

		// console.log("FUNC");
		// console.log(this.arguments);
		var argumentValues = [];
		var i = 0;
		function evalArgs(arguments,done) {
			if(i < arguments.length) {
				// Evaluate each argument
				arguments[i].Eval( environment, function(val) {
					argumentValues.push( val );
					i++;
					evalArgs(arguments,done);
				} );
			}
			else {
				done();
			}
		};
		var self = this; // hack to deal with scope
		evalArgs( this.arguments, function() {
			// Then evaluate the function
			// console.log("ARGS");
			// console.log(argumentValues);

			if( self.onExit != null ) self.onExit();

			environment.EvalFunction( self.name, argumentValues, onReturn );
		} );
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
		if(isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.arguments[0].value; // first argument should be the text of the {print} func
		}
		else if(isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.arguments.length; i++) {
				str += " ";
				str += this.arguments[i].Serialize(depth);
			}
			return str;
		}
	}
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if(this.value === null)
			return str;

		if(typeof this.value === "string") str += '"';
		str += this.value;
		if(typeof this.value === "string") str += '"';

		return str;
	}
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if(!isNegativeNumber) {
			var str = "";
			str += this.left.Serialize(depth);
			str += " " + this.operator + " ";
			str += this.right.Serialize(depth);
			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		if(this.left != null)
			this.left.VisitAll( visitor );
		if(this.right != null)
			this.right.VisitAll( visitor );
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.options.length; i++) {
			// console.log("SERIALIZE SEQUENCE ");
			// console.log(depth);
			str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.options.length; i++ ) {
			this.options[i].VisitAll( visitor );
		}
	};
}

var SequenceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "sequence";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("SEQUENCE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
	}
}

var CycleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "cycle";
	this.options = options;

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// console.log("CYCLE " + index);
		this.options[index].Eval( environment, onReturn );

		var next = index + 1;
		if(next < this.options.length)
			index = next;
		else
			index = 0;
	}
}

var ShuffleNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "shuffle";
	this.options = options;

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while(optionsUnshuffled.length > 0) {
			var i = Math.floor( Math.random() * optionsUnshuffled.length );
			optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
		}
	}
	shuffle(this.options);

	var index = 0;
	this.Eval = function(environment,onReturn) {
		// OLD RANDOM VERSION
		// var index = Math.floor(Math.random() * this.options.length);
		// this.options[index].Eval( environment, onReturn );

		optionsShuffled[index].Eval( environment, onReturn );
		
		index++;
		if (index >= this.options.length) {
			shuffle(this.options);
			index = 0;
		}
	}
}

var IfNode = function(conditions, results, isSingleLine) {
	Object.assign( this, new TreeRelationship() );
	this.type = "if";
	this.conditions = conditions;
	this.results = results;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		var self = this;
		function TestCondition() {
			// console.log("EVAL " + i);
			self.conditions[i].Eval(environment, function(val) {
				// console.log(val);
				if(val == true) {
					self.results[i].Eval(environment, onReturn);
				}
				else if(i+1 < self.conditions.length) {
					i++;
					TestCondition(); // test next condition
				}
				else {
					onReturn(null); // out of conditions and none were true
				}
			});
		};
		TestCondition();
	}

	if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
			if(this.conditions.length > 1 && this.conditions[1].type === "else")
				str += " : " + this.results[1].Serialize();
		}
		else {
			str += "\n";
			for (var i = 0; i < this.conditions.length; i++) {
				str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
				str += this.results[i].Serialize(depth + 2) + "\n";
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor) {
		visitor.Visit( this );
		for( var i = 0; i < this.conditions.length; i++ ) {
			this.conditions[i].VisitAll( visitor );
		}
		for( var i = 0; i < this.results.length; i++ ) {
			this.results[i].VisitAll( visitor );
		}
	};
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "else";

	this.Eval = function(environment,onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return "else";
	}
}

var Sym = {
	// DialogOpen : "/\"",
	// DialogClose : "\"/",
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"'
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr) {
		// console.log("NEW PARSE!!!!!!");

		// TODO : make this work for single-line, no dialog block scripts

		var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

		if( state.MatchAhead(Sym.DialogOpen) ) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
			state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
			state = ParseDialog( state );
		}
		// else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
		// 	// code-block: should this ever happen?
		// 	state = ParseCodeBlock( state );
		// }
		else {
			// single-line dialog block
			state = ParseDialog( state );
		}

		// console.log( state.rootNode );
		return state.rootNode;
	};

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
		}
		return { script:scriptStr, index:i };
	}

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for(var j = 0; j < str.length; j++) {
				if( i + j >= sourceStr.length )
					return false;
				else if( str[j] != sourceStr[i+j] )
					return false;
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function( open, close ) {
			var startIndex = i;

			var matchCount = 0;
			if( this.MatchAhead( open ) ) {
				matchCount++;
				this.Step( open.length );
			}

			while( matchCount > 0 && !this.Done() ) {
				if( this.MatchAhead( close ) ) {
					matchCount--;
					this.Step( close.length );
				}
				else if( this.MatchAhead( open ) ) {
					matchCount++;
					this.Step( open.length );
				}
				else {
					this.Step();
				}
			}

			// console.log("!!! " + startIndex + " " + i);

			return sourceStr.slice( startIndex + open.length, i - close.length );
		}
		this.Print = function() { /*console.log(sourceStr);*/ };
	};

	function ParseDialog(state) {
		// console.log("PARSE DIALOG");
		state.Print();

		// for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
		var hasBlock = false;
		var hasDialog = false;
		var isFirstLine = true;

		// console.log("---- PARSE DIALOG ----");

		var text = "";
		var addTextNode = function() {
			// console.log("TEXT " + text.length);
			if (text.length > 0) {
				// console.log("TEXT " + text);
				// console.log("text!!");
				// console.log([text]);

				state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
				text = "";

				hasDialog = true;
			}
		}

		while ( !state.Done() ) {

			if( state.MatchAhead(Sym.CodeOpen) ) {
				addTextNode();
				state = ParseCodeBlock( state );

				// console.log("CODE");

				var len = state.curNode.children.length;
				if(len > 0 && state.curNode.children[len-1].type === "block") {
					var block = state.curNode.children[len-1];
					if(isMultilineListBlock(block))
						hasDialog = true; // hack to get correct newline behavior for multiline blocks
				}

				hasBlock = true;
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	addTextNode();
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)

			// 	hasBlock = true;
			// }
			else {
				if ( state.MatchAhead(Sym.Linebreak) ) {
					addTextNode();

					/*
					NOTES:
					linebreaks SHOULD happen on
					- lines with text (including the first or last line)
					- empty lines (that are NOT the first or last line)
					linebreaks should NOT happen on
					- lines with only CODE blocks
					- empty FIRST or LAST lines

					also, apparently:
					- NEVER line break on the last line
					*/
					var isLastLine = (state.Index() + 1) == state.Count();
					// console.log("block " + hasBlock);
					// console.log("dialog " + hasDialog);
					var isEmptyLine = !hasBlock && !hasDialog;
					// console.log("empty " + isEmptyLine);
					var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
					// console.log("valid empty " + isValidEmptyLine);
					var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
					// console.log("LINEBREAK? " + shouldAddLinebreak);
					if( shouldAddLinebreak ) {
						// console.log("NEWLINE");
						// console.log("empty? " + isEmptyLine);
						// console.log("dialog? " + hasDialog);
						state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
					}

					// linebreak logic
					isFirstLine = false;
					hasBlock = false;
					hasDialog = false;

					text = "";
				}
				else {
					text += state.Char();
				}
				state.Step();
			}

		}
		addTextNode();

		// console.log("---- PARSE DIALOG ----");

		// console.log(state);
		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	function ParseIf(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var isNewline = true;
		var isConditionDone = false;
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				curIndex++;
				isConditionDone = false;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}
			else if(curIndex > -1) {
				if(!isConditionDone) {
					if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
						// end of condition
						isConditionDone = true;
					}
					else {
						// read in condition
						conditionStrings[curIndex] += state.Char();
					}
				}
				else {
					// read in result
					if(!isSkippableWhitespace)
						resultStrings[curIndex] += state.Char();
				}
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			state.Step();
		}

		// console.log("PARSE IF:");
		// console.log(conditionStrings);
		// console.log(resultStrings);

		var conditions = [];
		for(var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if(str === "else") {
				conditions.push( new ElseNode() );
			}
			else {
				var exp = CreateExpression( str );
				conditions.push( exp );
			}
		}

		var results = [];
		for(var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			results.push( dialogBlock );
		}

		state.curNode.AddChild( new IfNode( conditions, results ) );

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	// TODO: don't forget about eating whitespace
	function ParseSequence(state, sequenceType) {
		// console.log("SEQUENCE " + sequenceType);
		state.Print();

		var isNewline = false;
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var codeBlockCount = 0;

		while( !state.Done() ) {
			if(state.Char() === Sym.CodeOpen)
				codeBlockCount++;
			else if(state.Char() === Sym.CodeClose)
				codeBlockCount--;

			var isWhitespace = (state.Char() === " " || state.Char() === "\t");
			var isSkippableWhitespace = isNewline && isWhitespace;
			var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

			if(isNewListItem) {
				// console.log("found next list item");
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}
			else if(curItemIndex > -1) {
				if(!isSkippableWhitespace)
					itemStrings[curItemIndex] += state.Char();
			}

			isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

			// console.log(state.Char());
			state.Step();
		}
		// console.log(itemStrings);
		// console.log("SEQUENCE DONE");

		var options = [];
		for(var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
			dialogBlockState = ParseDialog( dialogBlockState );
			var dialogBlock = dialogBlockState.rootNode;
			options.push( dialogBlock );
		}

		// console.log(options);

		if(sequenceType === "sequence")
			state.curNode.AddChild( new SequenceNode( options ) );
		else if(sequenceType === "cycle")
			state.curNode.AddChild( new CycleNode( options ) );
		else if(sequenceType === "shuffle")
			state.curNode.AddChild( new ShuffleNode( options ) );

		return state;
	}

	function ParseFunction(state, funcName) {
		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	var setSymbol = "=";
	var ifSymbol = "?";
	var elseSymbol = ":";
	// var operatorSymbols = ["==", ">", "<", ">=", "<=", "*", "/", "+", "-"];
	var operatorSymbols = ["-", "+", "/", "*", "<=", ">=", "<", ">", "=="]; // operators need to be in reverse order
	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}
	
		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(setSymbol);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = setSymbol;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(ifSymbol);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = ifSymbol;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+ifSymbol.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
			var opSym = operatorSymbols[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function ParseExpression(state) {
		var line = state.Peak( [Sym.Linebreak] );
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression( line );
		// console.log(exp);
		state.curNode.AddChild( exp );
		state.Step( line.length );
		return state;
	}

	function ParseCode(state) {
		// TODO : how do I do this parsing??? one expression per block? or per line?
		while ( !state.Done() ) {

			if( state.Char() === " " || state.Char() === "\t" || state.Char() === "\n" ) { // TODO: symbols? IsWhitespace func?
				state.Step(); // consume whitespace
			}
			else if( state.MatchAhead(Sym.CodeOpen) ) {
				state = ParseCodeBlock( state );
			}
			// NOTE: nested dialog blocks disabled for now
			// else if( state.MatchAhead(Sym.DialogOpen) ) {
			// 	state = ParseDialogBlock( state ); // These can be nested (should they though???)
			// }
			else if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
				// console.log("PEAK IF " + state.Peak( ["?"] ));
				state = ParseIf( state );
			}
			else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
				var funcName = state.Peak( [" "] );
				state.Step( funcName.length );
				state = ParseFunction( state, funcName );
			}
			else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
				var sequenceType = state.Peak( [" ", Sym.Linebreak] );
				state.Step( sequenceType.length );
				state = ParseSequence( state, sequenceType );
			}
			else {
				state = ParseExpression( state );
			}
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

		// console.log("PARSE CODE");
		// console.log(codeStr);

		var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
		codeState = ParseCode( codeState );
		
		state.curNode.AddChild( codeState.rootNode );

		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {x:0, y:0};

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer,dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar( this.DrawChar );

		if( buffer.CanContinue() )
			this.DrawNextArrow();

		this.DrawTextbox();

		if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
			onPageFinish();
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					leftPos += char.width;
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		activeTextEffects = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		// console.log("DO NEXT CHAR");

		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;

			// console.log("WAITING FOR INPUT");
		}

		// console.log(this.CurChar());
		if(this.CurChar() != null)
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		console.log("END!!!!");
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog
	}

	this.Continue = function() {
		console.log("CONTINUE");
		if (pageIndex + 1 < this.CurPageCount()) {
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		this.bitmap = font.getChar(char);
		this.width = font.getWidth();
		this.height = font.getHeight();
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].width;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			width += font.getWidth();
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddDrawing = function(drawingId, onFinishHandler) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
		drawingChar.SetPrintHandler( onFinishHandler );

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (rowLength + drawingChar.width  <= pixelsPerRow || rowLength <= 0)
		{
			//stay on same row
			curRowArr.push( drawingChar );
		}
		else if (curRowIndex == 0)
		{
			//start next row
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer[ curPageIndex ].push( [] );
			curRowIndex++;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}
		else {
			//start next page
			buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
			buffer.push( [] );
			curPageIndex++;
			buffer[ curPageIndex ].push( [] );
			curRowIndex = 0;
			curRowArr = buffer[ curPageIndex ][ curRowIndex ];
			curRowArr.push( drawingChar );
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr,onFinishHandler) {
		// console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth( wordWithPrecedingSpace );

			var rowLength = GetCharArrayWidth(curRowArr);

			if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer[ curPageIndex ].push( [] );
				curRowIndex++;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
			else {
				//start next page
				buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
				buffer.push( [] );
				curPageIndex++;
				buffer[ curPageIndex ].push( [] );
				curRowIndex = 0;
				curRowArr = buffer[ curPageIndex ][ curRowIndex ];
				curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[ buffer.length-1 ];
		var lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length == 0 )
			lastPage.splice( lastPage.length-1, 1 );
		if( lastPage.length == 0 )
			buffer.splice( buffer.length-1, 1 );

		//finish up 
		lastPage = buffer[ buffer.length-1 ];
		lastRow = lastPage[ lastPage.length-1 ];
		if( lastRow.length > 0 ) {
			var lastChar = lastRow[ lastRow.length-1 ];
			lastChar.SetPrintHandler( onFinishHandler );
		}

		console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[ buffer.length-1 ];
		if( lastPage.length <= 1 ) {
			console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push( [] );
		}
		else {
			// add new page
			buffer.push( [[]] );
		}
		console.log(buffer);

		isActive = true;
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	return img;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = {
	"0" : [[0,0,0],[255,0,0],[255,255,255]] //start off with a default palette (can be overriden)
};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	/*dialog : new Map()*/ // TODO
	/*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
	names.room = new Map();
	for(id in room) {
		if(room[id].name != undefined && room[id].name != null)
			names.room.set( room[id].name, id );
	}
	names.tile = new Map();
	for(id in tile) {
		if(tile[id].name != undefined && tile[id].name != null)
			names.tile.set( tile[id].name, id );
	}
	names.sprite = new Map();
	for(id in sprite) {
		if(sprite[id].name != undefined && sprite[id].name != null)
			names.sprite.set( sprite[id].name, id );
	}
	names.item = new Map();
	for(id in item) {
		if(item[id].name != undefined && item[id].name != null)
			names.item.set( item[id].name, id );
	}
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 5, // for file format / engine changes
	minor: 3 // for editor changes and bugfixes
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

function clearGameData() {
	title = "";
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette (can be overriden)
		"0" : {
			name : null,
			colors : [[0,0,0],[255,0,0],[255,255,255]]
		}
	};
	ending = {};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map()
	};

	fontName = defaultFontName; // TODO : reset font manager too?
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) return; //can't reset if we don't have the game data
	stopGame();
	clearGameData();
	load_game(curGameData);
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart);
		canvas.addEventListener('touchmove', input.ontouchmove);
		canvas.addEventListener('touchend', input.ontouchend);
	}
	else {
		document.addEventListener('touchstart', input.ontouchstart);
		document.addEventListener('touchmove', input.ontouchmove);
		document.addEventListener('touchend', input.ontouchend);
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,-1);

	console.log("TITLE ??? " + startWithTitle);
	if(startWithTitle) // used by editor
		startNarrating(title);
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
	from.trail = [];
	var visited = [];
	var queue = [from];
	visited.push( posToString(from) );

	//console.log( "~ bfs ~");
	//console.log( posToString(from) + " to " + posToString(to) );

	while ( queue.length > 0 ) {

		//grab pos from queue and mark as visited
		var curPos = queue.shift();

		//console.log( posToString(curPos) );
		//console.log( ".. " + pathToString(curPos.trail) );
		//console.log( visited );

		if (curPos.x == to.x && curPos.y == to.y) {
			//found a path!
			var path = curPos.trail.splice(0);
			path.push( curPos );
			return path;
		}

		//look at neighbors
		neighbors(curPos).forEach( function(n) {
			var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
			if (inBounds) {
				var noCollision = map[n.y][n.x] <= 0;
				var notVisited = visited.indexOf( posToString(n) ) == -1;
				if (noCollision && notVisited) {
					n.trail = curPos.trail.slice();
					n.trail.push(curPos);
					queue.push( n );
					visited.push( posToString(n) );
				}
			}
		});

	}

	return []; // no path found
}

function posToString(pos) {
	return pos.x + "," + pos.y;
}

function pathToString(path) {
	var s = "";
	for (i in path) {
		s += posToString(path[i]) + " ";
	}
	return s;
}

function neighbors(pos) {
	var neighborList = [];
	neighborList.push( {x:pos.x+1, y:pos.y+0} );
	neighborList.push( {x:pos.x-1, y:pos.y+0} );
	neighborList.push( {x:pos.x+0, y:pos.y+1} );
	neighborList.push( {x:pos.x+0, y:pos.y-1} );
	return neighborList;
}

function collisionMap(roomId) {
	var map = [
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	];

	for (r in room[roomId].tilemap) {
		var row = room[roomId].tilemap[r];
		for (var c = 0; c < row.length; c++) {
			if (room[roomId].walls.indexOf( row[x] ) != -1) {
				map[r][c] = 1;
			}
		}
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			map[spr.y][spr.x] = 2;
		}
	}

	return map;
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		document.removeEventListener('touchstart', input.ontouchstart);
		document.removeEventListener('touchmove', input.ontouchmove);
		document.removeEventListener('touchend', input.ontouchend);
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	updateInput();

	if (!isNarrating && !isEnding) {
		updateAnimation();
		drawRoom( room[curRoom] ); // draw world if game has begun
	}
	else {
		//make sure to still clear screen
		ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
		ctx.fillRect(0,0,canvas.width,canvas.height);
	}

	// if (isDialogMode) { // dialog mode
	if(dialogBuffer.IsActive()) {
		dialogRenderer.Draw( dialogBuffer, deltaTime );
		dialogBuffer.Update( deltaTime );
	}
	else if (!isEnding) {
		moveSprites();
	}

	// keep moving avatar if player holds down button
	if( !dialogBuffer.IsActive() && !isEnding )
	{
		if( curPlayerDirection != Direction.None ) {
			playerHoldToMoveTimer -= deltaTime;

			if( playerHoldToMoveTimer <= 0 )
			{
				movePlayer( curPlayerDirection );
				playerHoldToMoveTimer = 150;
			}
		}
	}

	prevTime = curTime;

	//for gif recording
	if (didPlayerMoveThisFrame && onPlayerMoved != null) onPlayerMoved();
	didPlayerMoveThisFrame = false;
	// if (didDialogUpdateThisFrame && onDialogUpdate != null) onDialogUpdate();
	// didDialogUpdateThisFrame = false;
	/* hacky replacement */
	if (onDialogUpdate != null)
		dialogRenderer.SetPageFinishHandler( onDialogUpdate );

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();

					onExitDialog();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
	moveCounter += deltaTime;

	if (moveCounter >= moveTime) {

		for (id in sprite) {
			var spr = sprite[id];
			if (spr.walkingPath.length > 0) {
				//move sprite
				var nextPos = spr.walkingPath.shift();
				spr.x = nextPos.x;
				spr.y = nextPos.y;


				var end = getEnding( spr.room, spr.x, spr.y );
				var ext = getExit( spr.room, spr.x, spr.y );
				var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
				if (end) { //if the sprite hits an ending
					if (id === playerId) { // only the player can end the game
						startNarrating( ending[end.id], true /*isEnding*/ );
					}
				}
				else if (ext) { //if the sprite hits an exit
					//move it to another scene
					spr.room = ext.dest.room;
					spr.x = ext.dest.x;
					spr.y = ext.dest.y;
					if (id === playerId) {
						//if the player changes scenes, change the visible scene
						curRoom = ext.dest.room;
					}
				}
				else if(itmIndex > -1) {
					var itm = room[ spr.room ].items[ itmIndex ];
					room[ spr.room ].items.splice( itmIndex, 1 );
					if( spr.inventory[ itm.id ] )
						spr.inventory[ itm.id ] += 1;
					else
						spr.inventory[ itm.id ] = 1;

					if(onInventoryChanged != null)
						onInventoryChanged( itm.id );

					if(id === playerId)
						startItemDialog( itm.id  /*itemId*/ );

					// stop moving : is this a good idea?
					spr.walkingPath = [];
				}

				if (id === playerId) didPlayerMoveThisFrame = true;
			}
		}

		moveCounter = 0;
	}

}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
		didPlayerMoveThisFrame = true;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
		didPlayerMoveThisFrame = true;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		// TODO pick up items (what about touch?)
		// console.log("HIT ITM ");
		// console.log( itmIndex );
		var itm = room[ player().room ].items[ itmIndex ];
		// console.log(itm);
		room[ player().room ].items.splice( itmIndex, 1 );
		if( player().inventory[ itm.id ] )
			player().inventory[ itm.id ] += 1;
		else
			player().inventory[ itm.id ] = 1;

		if(onInventoryChanged != null)
			onInventoryChanged( itm.id );

		startItemDialog( itm.id  /*itemId*/ );

		// console.log( player().inventory );
	}

	if (end) {
		startNarrating( ending[end.id], true /*isEnding*/ );
	}
	else if (ext) {
		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;
	}
	else if (spr) {
		startSpriteDialog( spr /*spriteId*/ );
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	// console.log("~~~ PARSE WORLD ~~~");
	// console.log(file);

	// var parseTimer = new Timer();

	resetFlags();

	var versionNumber = 0;

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i);
		}
		else if (getType(curLine) === "END") {
			i = parseEnding(lines, i);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}
	placeSprites();
	if (player().room != null) {
		curRoom = player().room;
	}

	renderer.SetPalettes(palette);

	// console.log(names);

	// console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

	return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += title + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		worldStr += "PAL " + id + "\n";
		if( palette[id].name != null )
			worldStr += "NAME " + palette[id].name + "\n";
		for (i in getPal(id)) {
			for (j in getPal(id)[i]) {
				worldStr += getPal(id)[i][j];
				if (j < 2) worldStr += ",";
			}
			worldStr += "\n";
		}
		worldStr += "\n";
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null) {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		worldStr += "DLG " + id + "\n";
		worldStr += dialog[id] + "\n";
		worldStr += "\n";
	}
	/* ENDINGS */
	for (id in ending) {
		worldStr += "END " + id + "\n";
		worldStr += ending[id] + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	title = lines[i];
	i++;
	return i;
}

function parseRoom(lines, i) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				}
			};
			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId( lines[i] );
			var endCoords = getCoord( lines[i], 2 );
			var end = {
				id : endId,
				x : parseInt( endCoords[0] ),
				y : parseInt( endCoords[1] )
			};
			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set( name, id);
		}
		i++;
	}
	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if(args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		walkingPath : [], //tile by tile movement path (isn't saved)
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

function parseDialog(lines, i) {
	var id = getId(lines[i]);
	i++;

	// TODO : use this for titles & endings too
	var results = scriptInterpreter.ReadDialogScript(lines,i);
	dialog[id] = results.script;
	i = results.index;

	return i;
}

function parseEnding(lines, i) {
	var id = getId(lines[i]);
	i++;
	var text = lines[i];
	i++;
	ending[id] = text;
	return i;
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	context.putImageData(img,x*tilesize*scale,y*tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	//clear screen
	context.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],getRoomPal(room.id),frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],getRoomPal(room.id),frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,getRoomPal(room.id),frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return "0";
		}
	}
	return "0";	
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog() {
	// var breakShit = null;
	// breakShit();
	console.log("EXIT DIALOG");
	isDialogMode = false;
	if (isNarrating) isNarrating = false;
	if (isDialogPreview) {
		isDialogPreview = false;
		if (onDialogPreviewEnd != null)
			onDialogPreviewEnd();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) end = false;

	isNarrating = true;
	isEnding = end;
	startDialog(dialogStr);
}

function startItemDialog(itemId) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg ? spr.dlg : spriteId;
	// console.log("START SPRITE DIALOG " + dialogId);
	if(dialog[dialogId]){
		var dialogStr = dialog[dialogId];
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr,scriptId) {
	console.log("START DIALOG ");
	console.log(dialogStr);

	if(dialogStr.length <= 0) {
		console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog();
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( isNarrating /*centered*/ );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	var onScriptEnd = function() {
		if(!dialogBuffer.IsActive()){
			console.log("ON EXIT DIALOG -- startDialog 2");
			onExitDialog();
		}
	};

	if(scriptId === undefined) {
		scriptInterpreter.Interpret( dialogStr, onScriptEnd );		
	}
	else {
		if( !scriptInterpreter.HasScript(scriptId) )
			scriptInterpreter.Compile( scriptId, dialogStr );
		scriptInterpreter.Run( scriptId, onScriptEnd );
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered( true );
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer( dialogBuffer );

	onDialogPreviewEnd = onScriptEnd;

	scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- store default font in separate script tag for back compat-->
<script type="bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>